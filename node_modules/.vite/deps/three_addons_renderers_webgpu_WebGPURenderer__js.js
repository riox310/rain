import {
  WebGPU_default
} from "./chunk-IKI57UBH.js";
import {
  ChainMap,
  CodeNode_default,
  GLSLNodeParser_default,
  LightsNode_default,
  MathNode_default,
  NodeBuilder_default,
  NodeFrame_default,
  NodeFunctionInput_default,
  NodeFunction_default,
  NodeMaterial_default,
  NodeParser_default,
  backgroundBlurriness,
  backgroundIntensity,
  context,
  cubeTexture,
  densityFog,
  equirectUV,
  frameGroup,
  modelViewProjection,
  normalWorld,
  objectGroup,
  rangeFog,
  reference,
  renderGroup,
  texture,
  toneMapping,
  vec4,
  viewportBottomLeft
} from "./chunk-ZBIODU75.js";
import {
  AddEquation,
  AdditiveBlending,
  AlphaFormat,
  AlwaysCompare,
  AlwaysDepth,
  AlwaysStencilFunc,
  BackSide,
  ByteType,
  ClampToEdgeWrapping,
  Color,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CullFaceBack,
  CullFaceFront,
  CullFaceNone,
  CustomBlending,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicDrawUsage,
  EqualCompare,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Float16BufferAttribute,
  FloatType,
  FrontSide,
  Frustum,
  GreaterCompare,
  GreaterDepth,
  GreaterEqualCompare,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  HalfFloatType,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  IntType,
  InvertStencilOp,
  KeepStencilOp,
  LessCompare,
  LessDepth,
  LessEqualCompare,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LuminanceAlphaFormat,
  LuminanceFormat,
  Matrix4,
  MaxEquation,
  Mesh,
  MinEquation,
  MirroredRepeatWrapping,
  MultiplyBlending,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeverCompare,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  NormalBlending,
  NotEqualCompare,
  NotEqualDepth,
  NotEqualStencilFunc,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  RED_GREEN_RGTC2_Format,
  RED_RGTC1_Format,
  REVISION,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RGIntegerFormat,
  RedFormat,
  RedIntegerFormat,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  SIGNED_RED_GREEN_RGTC2_Format,
  SIGNED_RED_RGTC1_Format,
  SRGBColorSpace,
  Scene,
  ShortType,
  SphereGeometry,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  SubtractEquation,
  SubtractiveBlending,
  Texture,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  WebGLCoordinateSystem,
  WebGPUCoordinateSystem,
  ZeroFactor,
  ZeroStencilOp,
  createCanvasElement
} from "./chunk-D5NTCM2J.js";
import "./chunk-CSAU5B4Q.js";

// node_modules/three/examples/jsm/renderers/common/Animation.js
var Animation = class {
  constructor(nodes, info) {
    this.nodes = nodes;
    this.info = info;
    this.animationLoop = null;
    this.requestId = null;
    this._init();
  }
  _init() {
    const update = (time, frame) => {
      this.requestId = self.requestAnimationFrame(update);
      this.nodes.nodeFrame.update();
      this.info.frame = this.nodes.nodeFrame.frameId;
      if (this.animationLoop !== null)
        this.animationLoop(time, frame);
    };
    update();
  }
  dispose() {
    self.cancelAnimationFrame(this.requestId);
  }
  setAnimationLoop(callback) {
    this.animationLoop = callback;
  }
};
var Animation_default = Animation;

// node_modules/three/examples/jsm/renderers/common/RenderObject.js
var id = 0;
var RenderObject = class {
  constructor(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext) {
    this._nodes = nodes;
    this._geometries = geometries;
    this.id = id++;
    this.renderer = renderer;
    this.object = object;
    this.material = material;
    this.scene = scene;
    this.camera = camera;
    this.lightsNode = lightsNode;
    this.context = renderContext;
    this.geometry = object.geometry;
    this.version = material.version;
    this.attributes = null;
    this.pipeline = null;
    this.vertexBuffers = null;
    this.initialNodesCacheKey = this.getNodesCacheKey();
    this.initialCacheKey = this.getCacheKey();
    this._nodeBuilderState = null;
    this._bindings = null;
    this.onDispose = null;
    this.isRenderObject = true;
    this.onMaterialDispose = () => {
      this.dispose();
    };
    this.material.addEventListener("dispose", this.onMaterialDispose);
  }
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  getIndex() {
    return this._geometries.getIndex(this);
  }
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  getAttributes() {
    if (this.attributes !== null)
      return this.attributes;
    const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
    const geometry = this.geometry;
    const attributes = [];
    const vertexBuffers = /* @__PURE__ */ new Set();
    for (const nodeAttribute of nodeAttributes) {
      const attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute(nodeAttribute.name);
      attributes.push(attribute);
      const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
      vertexBuffers.add(bufferAttribute);
    }
    this.attributes = attributes;
    this.vertexBuffers = Array.from(vertexBuffers.values());
    return attributes;
  }
  getVertexBuffers() {
    if (this.vertexBuffers === null)
      this.getAttributes();
    return this.vertexBuffers;
  }
  getMaterialCacheKey() {
    const { object, material } = this;
    let cacheKey = material.customProgramCacheKey();
    for (const property in material) {
      if (/^(is[A-Z])|^(visible|version|uuid|name|opacity|userData)$/.test(property))
        continue;
      let value = material[property];
      if (value !== null) {
        const type = typeof value;
        if (type === "number")
          value = value !== 0 ? "1" : "0";
        else if (type === "object")
          value = "{}";
      }
      cacheKey += /*property + ':' +*/
      value + ",";
    }
    if (object.skeleton) {
      cacheKey += object.skeleton.uuid + ",";
    }
    if (object.morphTargetInfluences) {
      cacheKey += object.morphTargetInfluences.length + ",";
    }
    return cacheKey;
  }
  get needsUpdate() {
    return this.initialNodesCacheKey !== this.getNodesCacheKey();
  }
  getNodesCacheKey() {
    return this._nodes.getCacheKey(this.scene, this.lightsNode);
  }
  getCacheKey() {
    return this.getMaterialCacheKey() + "," + this.getNodesCacheKey();
  }
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose);
    this.onDispose();
  }
};

// node_modules/three/examples/jsm/renderers/common/RenderObjects.js
var RenderObjects = class {
  constructor(renderer, nodes, geometries, pipelines, bindings, info) {
    this.renderer = renderer;
    this.nodes = nodes;
    this.geometries = geometries;
    this.pipelines = pipelines;
    this.bindings = bindings;
    this.info = info;
    this.chainMaps = {};
  }
  get(object, material, scene, camera, lightsNode, renderContext, passId) {
    const chainMap = this.getChainMap(passId);
    const chainArray = [object, material, renderContext, lightsNode];
    let renderObject = chainMap.get(chainArray);
    if (renderObject === void 0) {
      renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, passId);
      chainMap.set(chainArray, renderObject);
    } else {
      if (renderObject.version !== material.version || renderObject.needsUpdate) {
        if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
          renderObject.dispose();
          renderObject = this.get(object, material, scene, camera, lightsNode, renderContext, passId);
        } else {
          renderObject.version = material.version;
        }
      }
    }
    return renderObject;
  }
  getChainMap(passId = "default") {
    return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
  }
  dispose() {
    this.chainMaps = {};
  }
  createRenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, passId) {
    const chainMap = this.getChainMap(passId);
    const renderObject = new RenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext);
    renderObject.onDispose = () => {
      this.pipelines.delete(renderObject);
      this.bindings.delete(renderObject);
      this.nodes.delete(renderObject);
      chainMap.delete(renderObject.getChainArray());
    };
    return renderObject;
  }
};
var RenderObjects_default = RenderObjects;

// node_modules/three/examples/jsm/renderers/common/DataMap.js
var DataMap = class {
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  get(object) {
    let map = this.data.get(object);
    if (map === void 0) {
      map = {};
      this.data.set(object, map);
    }
    return map;
  }
  delete(object) {
    let map;
    if (this.data.has(object)) {
      map = this.data.get(object);
      this.data.delete(object);
    }
    return map;
  }
  has(object) {
    return this.data.has(object);
  }
  dispose() {
    this.data.clear();
  }
};
var DataMap_default = DataMap;

// node_modules/three/examples/jsm/renderers/common/Constants.js
var AttributeType = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 4
};
var GPU_CHUNK_BYTES = 16;
var BlendColorFactor = 211;
var OneMinusBlendColorFactor = 212;

// node_modules/three/examples/jsm/renderers/common/Attributes.js
var Attributes = class extends DataMap_default {
  constructor(backend) {
    super();
    this.backend = backend;
  }
  delete(attribute) {
    const attributeData = super.delete(attribute);
    if (attributeData !== void 0) {
      this.backend.destroyAttribute(attribute);
    }
  }
  update(attribute, type) {
    const data = this.get(attribute);
    if (data.version === void 0) {
      if (type === AttributeType.VERTEX) {
        this.backend.createAttribute(attribute);
      } else if (type === AttributeType.INDEX) {
        this.backend.createIndexAttribute(attribute);
      } else if (type === AttributeType.STORAGE) {
        this.backend.createStorageAttribute(attribute);
      }
      data.version = this._getBufferAttribute(attribute).version;
    } else {
      const bufferAttribute = this._getBufferAttribute(attribute);
      if (data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage) {
        this.backend.updateAttribute(attribute);
        data.version = bufferAttribute.version;
      }
    }
  }
  _getBufferAttribute(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return attribute;
  }
};
var Attributes_default = Attributes;

// node_modules/three/examples/jsm/renderers/common/Geometries.js
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535)
      return true;
  }
  return false;
}
function getWireframeVersion(geometry) {
  return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
}
function getWireframeIndex(geometry) {
  const indices = [];
  const geometryIndex = geometry.index;
  const geometryPosition = geometry.attributes.position;
  if (geometryIndex !== null) {
    const array = geometryIndex.array;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const a = array[i + 0];
      const b = array[i + 1];
      const c = array[i + 2];
      indices.push(a, b, b, c, c, a);
    }
  } else {
    const array = geometryPosition.array;
    for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
      const a = i + 0;
      const b = i + 1;
      const c = i + 2;
      indices.push(a, b, b, c, c, a);
    }
  }
  const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
  attribute.version = getWireframeVersion(geometry);
  return attribute;
}
var Geometries = class extends DataMap_default {
  constructor(attributes, info) {
    super();
    this.attributes = attributes;
    this.info = info;
    this.wireframes = /* @__PURE__ */ new WeakMap();
    this.attributeCall = /* @__PURE__ */ new WeakMap();
  }
  has(renderObject) {
    const geometry = renderObject.geometry;
    return super.has(geometry) && this.get(geometry).initialized === true;
  }
  updateForRender(renderObject) {
    if (this.has(renderObject) === false)
      this.initGeometry(renderObject);
    this.updateAttributes(renderObject);
  }
  initGeometry(renderObject) {
    const geometry = renderObject.geometry;
    const geometryData = this.get(geometry);
    geometryData.initialized = true;
    this.info.memory.geometries++;
    const onDispose = () => {
      this.info.memory.geometries--;
      const index = geometry.index;
      const geometryAttributes = renderObject.getAttributes();
      if (index !== null) {
        this.attributes.delete(index);
      }
      for (const geometryAttribute of geometryAttributes) {
        this.attributes.delete(geometryAttribute);
      }
      const wireframeAttribute = this.wireframes.get(geometry);
      if (wireframeAttribute !== void 0) {
        this.attributes.delete(wireframeAttribute);
      }
      geometry.removeEventListener("dispose", onDispose);
    };
    geometry.addEventListener("dispose", onDispose);
  }
  updateAttributes(renderObject) {
    const attributes = renderObject.getAttributes();
    for (const attribute of attributes) {
      this.updateAttribute(attribute, AttributeType.VERTEX);
    }
    const index = this.getIndex(renderObject);
    if (index !== null) {
      this.updateAttribute(index, AttributeType.INDEX);
    }
  }
  updateAttribute(attribute, type) {
    const callId = this.info.render.calls;
    if (this.attributeCall.get(attribute) !== callId) {
      this.attributes.update(attribute, type);
      this.attributeCall.set(attribute, callId);
    }
  }
  getIndex(renderObject) {
    const { geometry, material } = renderObject;
    let index = geometry.index;
    if (material.wireframe === true) {
      const wireframes = this.wireframes;
      let wireframeAttribute = wireframes.get(geometry);
      if (wireframeAttribute === void 0) {
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {
        this.attributes.delete(wireframeAttribute);
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      }
      index = wireframeAttribute;
    }
    return index;
  }
};
var Geometries_default = Geometries;

// node_modules/three/examples/jsm/renderers/common/Info.js
var Info = class {
  constructor() {
    this.autoReset = true;
    this.frame = 0;
    this.calls = 0;
    this.render = {
      calls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    this.compute = {
      calls: 0
    };
    this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  update(object, count, instanceCount) {
    this.render.drawCalls++;
    if (object.isMesh || object.isSprite) {
      this.render.triangles += instanceCount * (count / 3);
    } else if (object.isPoints) {
      this.render.points += instanceCount * count;
    } else if (object.isLineSegments) {
      this.render.lines += instanceCount * (count / 2);
    } else if (object.isLine) {
      this.render.lines += instanceCount * (count - 1);
    } else {
      console.error("THREE.WebGPUInfo: Unknown object type.");
    }
  }
  reset() {
    this.render.drawCalls = 0;
    this.render.triangles = 0;
    this.render.points = 0;
    this.render.lines = 0;
  }
  dispose() {
    this.reset();
    this.calls = 0;
    this.render.calls = 0;
    this.compute.calls = 0;
    this.memory.geometries = 0;
    this.memory.textures = 0;
  }
};
var Info_default = Info;

// node_modules/three/examples/jsm/renderers/common/Pipeline.js
var Pipeline = class {
  constructor(cacheKey) {
    this.cacheKey = cacheKey;
    this.usedTimes = 0;
  }
};
var Pipeline_default = Pipeline;

// node_modules/three/examples/jsm/renderers/common/RenderPipeline.js
var RenderPipeline = class extends Pipeline_default {
  constructor(cacheKey, vertexProgram, fragmentProgram) {
    super(cacheKey);
    this.vertexProgram = vertexProgram;
    this.fragmentProgram = fragmentProgram;
  }
};
var RenderPipeline_default = RenderPipeline;

// node_modules/three/examples/jsm/renderers/common/ComputePipeline.js
var ComputePipeline = class extends Pipeline_default {
  constructor(cacheKey, computeProgram) {
    super(cacheKey);
    this.computeProgram = computeProgram;
    this.isComputePipeline = true;
  }
};
var ComputePipeline_default = ComputePipeline;

// node_modules/three/examples/jsm/renderers/common/ProgrammableStage.js
var _id = 0;
var ProgrammableStage = class {
  constructor(code, type) {
    this.id = _id++;
    this.code = code;
    this.stage = type;
    this.usedTimes = 0;
  }
};
var ProgrammableStage_default = ProgrammableStage;

// node_modules/three/examples/jsm/renderers/common/Pipelines.js
var Pipelines = class extends DataMap_default {
  constructor(backend, nodes) {
    super();
    this.backend = backend;
    this.nodes = nodes;
    this.bindings = null;
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  getForCompute(computeNode, bindings) {
    const { backend } = this;
    const data = this.get(computeNode);
    if (this._needsComputeUpdate(computeNode)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.computeProgram.usedTimes--;
      }
      const nodeBuilder = this.nodes.getForCompute(computeNode);
      let stageCompute = this.programs.compute.get(nodeBuilder.computeShader);
      if (stageCompute === void 0) {
        if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0)
          this._releaseProgram(previousPipeline.computeProgram);
        stageCompute = new ProgrammableStage_default(nodeBuilder.computeShader, "compute");
        this.programs.compute.set(nodeBuilder.computeShader, stageCompute);
        backend.createProgram(stageCompute);
      }
      const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0)
          this._releasePipeline(computeNode);
        pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);
      }
      pipeline.usedTimes++;
      stageCompute.usedTimes++;
      data.version = computeNode.version;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  getForRender(renderObject) {
    const { backend } = this;
    const data = this.get(renderObject);
    if (this._needsRenderUpdate(renderObject)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.vertexProgram.usedTimes--;
        previousPipeline.fragmentProgram.usedTimes--;
      }
      const nodeBuilderState = renderObject.getNodeBuilderState();
      let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
      if (stageVertex === void 0) {
        if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0)
          this._releaseProgram(previousPipeline.vertexProgram);
        stageVertex = new ProgrammableStage_default(nodeBuilderState.vertexShader, "vertex");
        this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
        backend.createProgram(stageVertex);
      }
      let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
      if (stageFragment === void 0) {
        if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0)
          this._releaseProgram(previousPipeline.fragmentProgram);
        stageFragment = new ProgrammableStage_default(nodeBuilderState.fragmentShader, "fragment");
        this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
        backend.createProgram(stageFragment);
      }
      const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0)
          this._releasePipeline(previousPipeline);
        pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey);
      } else {
        renderObject.pipeline = pipeline;
      }
      pipeline.usedTimes++;
      stageVertex.usedTimes++;
      stageFragment.usedTimes++;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  delete(object) {
    const pipeline = this.get(object).pipeline;
    if (pipeline) {
      pipeline.usedTimes--;
      if (pipeline.usedTimes === 0)
        this._releasePipeline(pipeline);
      if (pipeline.isComputePipeline) {
        pipeline.computeProgram.usedTimes--;
        if (pipeline.computeProgram.usedTimes === 0)
          this._releaseProgram(pipeline.computeProgram);
      } else {
        pipeline.fragmentProgram.usedTimes--;
        pipeline.vertexProgram.usedTimes--;
        if (pipeline.vertexProgram.usedTimes === 0)
          this._releaseProgram(pipeline.vertexProgram);
        if (pipeline.fragmentProgram.usedTimes === 0)
          this._releaseProgram(pipeline.fragmentProgram);
      }
    }
    super.delete(object);
  }
  dispose() {
    super.dispose();
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  updateForRender(renderObject) {
    this.getForRender(renderObject);
  }
  _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
    cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new ComputePipeline_default(cacheKey, stageCompute);
      this.caches.set(cacheKey, pipeline);
      this.backend.createComputePipeline(pipeline, bindings);
    }
    return pipeline;
  }
  _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey) {
    cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new RenderPipeline_default(cacheKey, stageVertex, stageFragment);
      this.caches.set(cacheKey, pipeline);
      renderObject.pipeline = pipeline;
      this.backend.createRenderPipeline(renderObject);
    }
    return pipeline;
  }
  _getComputeCacheKey(computeNode, stageCompute) {
    return computeNode.id + "," + stageCompute.id;
  }
  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
    return stageVertex.id + "," + stageFragment.id + "," + this.backend.getRenderCacheKey(renderObject);
  }
  _releasePipeline(pipeline) {
    this.caches.delete(pipeline.cacheKey);
  }
  _releaseProgram(program) {
    const code = program.code;
    const stage = program.stage;
    this.programs[stage].delete(code);
  }
  _needsComputeUpdate(computeNode) {
    const data = this.get(computeNode);
    return data.pipeline === void 0 || data.version !== computeNode.version;
  }
  _needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    return data.pipeline === void 0 || this.backend.needsRenderUpdate(renderObject);
  }
};
var Pipelines_default = Pipelines;

// node_modules/three/examples/jsm/renderers/common/Bindings.js
var Bindings = class extends DataMap_default {
  constructor(backend, nodes, textures, attributes, pipelines, info) {
    super();
    this.backend = backend;
    this.textures = textures;
    this.pipelines = pipelines;
    this.attributes = attributes;
    this.nodes = nodes;
    this.info = info;
    this.pipelines.bindings = this;
  }
  getForRender(renderObject) {
    const bindings = renderObject.getBindings();
    const data = this.get(renderObject);
    if (data.bindings !== bindings) {
      data.bindings = bindings;
      this._init(bindings);
      this.backend.createBindings(bindings);
    }
    return data.bindings;
  }
  getForCompute(computeNode) {
    const data = this.get(computeNode);
    if (data.bindings === void 0) {
      const nodeBuilderState = this.nodes.getForCompute(computeNode);
      const bindings = nodeBuilderState.bindings.compute;
      data.bindings = bindings;
      this._init(bindings);
      this.backend.createBindings(bindings);
    }
    return data.bindings;
  }
  updateForCompute(computeNode) {
    this._update(computeNode, this.getForCompute(computeNode));
  }
  updateForRender(renderObject) {
    this._update(renderObject, this.getForRender(renderObject));
  }
  _init(bindings) {
    for (const binding of bindings) {
      if (binding.isSampledTexture) {
        this.textures.updateTexture(binding.texture);
      } else if (binding.isStorageBuffer) {
        const attribute = binding.attribute;
        this.attributes.update(attribute, AttributeType.STORAGE);
      }
    }
  }
  _update(object, bindings) {
    const { backend } = this;
    let needsBindingsUpdate = false;
    for (const binding of bindings) {
      if (binding.isNodeUniformsGroup) {
        const updated = this.nodes.updateGroup(binding);
        if (!updated)
          continue;
      }
      if (binding.isUniformBuffer) {
        const updated = binding.update();
        if (updated) {
          backend.updateBinding(binding);
        }
      } else if (binding.isSampledTexture) {
        const texture2 = binding.texture;
        if (binding.needsBindingsUpdate)
          needsBindingsUpdate = true;
        const updated = binding.update();
        if (updated) {
          this.textures.updateTexture(binding.texture);
        }
        if (texture2.isStorageTexture === true) {
          const textureData = this.get(texture2);
          if (binding.store === true) {
            textureData.needsMipmap = true;
          } else if (texture2.generateMipmaps === true && this.textures.needsMipmaps(texture2) && textureData.needsMipmap === true) {
            this.backend.generateMipmaps(texture2);
            textureData.needsMipmap = false;
          }
        }
      }
    }
    if (needsBindingsUpdate === true) {
      const pipeline = this.pipelines.getForRender(object);
      this.backend.updateBindings(bindings, pipeline);
    }
  }
};
var Bindings_default = Bindings;

// node_modules/three/examples/jsm/renderers/common/RenderList.js
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
var RenderList = class {
  constructor() {
    this.renderItems = [];
    this.renderItemsIndex = 0;
    this.opaque = [];
    this.transparent = [];
    this.lightsNode = new LightsNode_default([]);
    this.lightsArray = [];
    this.occlusionQueryCount = 0;
  }
  begin() {
    this.renderItemsIndex = 0;
    this.opaque.length = 0;
    this.transparent.length = 0;
    this.lightsArray.length = 0;
    this.occlusionQueryCount = 0;
    return this;
  }
  getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = this.renderItems[this.renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      this.renderItems[this.renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    this.renderItemsIndex++;
    return renderItem;
  }
  push(object, geometry, material, groupOrder, z, group) {
    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (object.occlusionTest === true)
      this.occlusionQueryCount++;
    (material.transparent === true ? this.transparent : this.opaque).push(renderItem);
  }
  unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? this.transparent : this.opaque).unshift(renderItem);
  }
  pushLight(light) {
    this.lightsArray.push(light);
  }
  getLightsNode() {
    return this.lightsNode.fromLights(this.lightsArray);
  }
  sort(customOpaqueSort, customTransparentSort) {
    if (this.opaque.length > 1)
      this.opaque.sort(customOpaqueSort || painterSortStable);
    if (this.transparent.length > 1)
      this.transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  finish() {
    this.lightsNode.fromLights(this.lightsArray);
    for (let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {
      const renderItem = this.renderItems[i];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.groupOrder = null;
      renderItem.renderOrder = null;
      renderItem.z = null;
      renderItem.group = null;
    }
  }
};
var RenderList_default = RenderList;

// node_modules/three/examples/jsm/renderers/common/RenderLists.js
var RenderLists = class {
  constructor() {
    this.lists = new ChainMap();
  }
  get(scene, camera) {
    const lists = this.lists;
    const keys = [scene, camera];
    let list = lists.get(keys);
    if (list === void 0) {
      list = new RenderList_default();
      lists.set(keys, list);
    }
    return list;
  }
  dispose() {
    this.lists = new ChainMap();
  }
};
var RenderLists_default = RenderLists;

// node_modules/three/examples/jsm/renderers/common/RenderContext.js
var id2 = 0;
var RenderContext = class {
  constructor() {
    this.id = id2++;
    this.color = true;
    this.clearColor = true;
    this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };
    this.depth = true;
    this.clearDepth = true;
    this.clearDepthValue = 1;
    this.stencil = true;
    this.clearStencil = true;
    this.clearStencilValue = 1;
    this.viewport = false;
    this.viewportValue = new Vector4();
    this.scissor = false;
    this.scissorValue = new Vector4();
    this.textures = null;
    this.depthTexture = null;
    this.activeCubeFace = 0;
    this.sampleCount = 1;
    this.width = 0;
    this.height = 0;
  }
};
var RenderContext_default = RenderContext;

// node_modules/three/examples/jsm/renderers/common/RenderContexts.js
var RenderContexts = class {
  constructor() {
    this.chainMaps = {};
  }
  get(scene, camera, renderTarget = null) {
    const chainKey = [scene, camera];
    let attachmentState;
    if (renderTarget === null) {
      attachmentState = "default";
    } else {
      let format, count;
      if (renderTarget.isWebGLMultipleRenderTargets) {
        format = renderTarget.texture[0].format;
        count = renderTarget.texture.length;
      } else {
        format = renderTarget.texture.format;
        count = 1;
      }
      attachmentState = `${count}:${format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;
    }
    const chainMap = this.getChainMap(attachmentState);
    let renderState = chainMap.get(chainKey);
    if (renderState === void 0) {
      renderState = new RenderContext_default();
      chainMap.set(chainKey, renderState);
    }
    if (renderTarget !== null)
      renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
    return renderState;
  }
  getChainMap(attachmentState) {
    return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
  }
  dispose() {
    this.chainMaps = {};
  }
};
var RenderContexts_default = RenderContexts;

// node_modules/three/examples/jsm/renderers/common/Textures.js
var _size = new Vector3();
var Textures = class extends DataMap_default {
  constructor(backend, info) {
    super();
    this.backend = backend;
    this.info = info;
  }
  updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
    const renderTargetData = this.get(renderTarget);
    const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
    const depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});
    let texture2, textures;
    if (renderTarget.isWebGLMultipleRenderTargets) {
      textures = renderTarget.texture;
      texture2 = renderTarget.texture[0];
    } else {
      textures = [renderTarget.texture];
      texture2 = renderTarget.texture;
    }
    const size = this.getSize(texture2);
    const mipWidth = size.width >> activeMipmapLevel;
    const mipHeight = size.height >> activeMipmapLevel;
    let depthTexture = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];
    let textureNeedsUpdate = false;
    if (depthTexture === void 0) {
      depthTexture = new DepthTexture();
      depthTexture.format = DepthStencilFormat;
      depthTexture.type = UnsignedInt248Type;
      depthTexture.image.width = mipWidth;
      depthTexture.image.height = mipHeight;
      depthTextureMips[activeMipmapLevel] = depthTexture;
    }
    if (renderTargetData.width !== size.width || size.height !== renderTargetData.height) {
      textureNeedsUpdate = true;
      depthTexture.needsUpdate = true;
      depthTexture.image.width = mipWidth;
      depthTexture.image.height = mipHeight;
    }
    renderTargetData.width = size.width;
    renderTargetData.height = size.height;
    renderTargetData.textures = textures;
    renderTargetData.depthTexture = depthTexture;
    renderTargetData.depth = renderTarget.depthBuffer;
    renderTargetData.stencil = renderTarget.stencilBuffer;
    if (renderTargetData.sampleCount !== sampleCount) {
      textureNeedsUpdate = true;
      depthTexture.needsUpdate = true;
      renderTargetData.sampleCount = sampleCount;
    }
    const options = { sampleCount };
    for (let i = 0; i < textures.length; i++) {
      const texture3 = textures[i];
      if (textureNeedsUpdate)
        texture3.needsUpdate = true;
      this.updateTexture(texture3, options);
    }
    this.updateTexture(depthTexture, options);
    if (renderTargetData.initialized !== true) {
      renderTargetData.initialized = true;
      const onDispose = () => {
        renderTarget.removeEventListener("dispose", onDispose);
        if (textures !== void 0) {
          for (let i = 0; i < textures.length; i++) {
            this._destroyTexture(textures[i]);
          }
        } else {
          this._destroyTexture(texture2);
        }
        this._destroyTexture(depthTexture);
      };
      renderTarget.addEventListener("dispose", onDispose);
    }
  }
  updateTexture(texture2, options = {}) {
    const textureData = this.get(texture2);
    if (textureData.initialized === true && textureData.version === texture2.version)
      return;
    const isRenderTarget = texture2.isRenderTargetTexture || texture2.isDepthTexture || texture2.isFramebufferTexture;
    const backend = this.backend;
    if (isRenderTarget && textureData.initialized === true) {
      backend.destroySampler(texture2);
      backend.destroyTexture(texture2);
    }
    const { width, height, depth } = this.getSize(texture2);
    options.width = width;
    options.height = height;
    options.depth = depth;
    options.needsMipmaps = this.needsMipmaps(texture2);
    options.levels = options.needsMipmaps ? this.getMipLevels(texture2, width, height) : 1;
    if (isRenderTarget || texture2.isStorageTexture === true) {
      backend.createSampler(texture2);
      backend.createTexture(texture2, options);
    } else {
      const needsCreate = textureData.initialized !== true;
      if (needsCreate)
        backend.createSampler(texture2);
      if (texture2.version > 0) {
        const image = texture2.image;
        if (image === void 0) {
          console.warn("THREE.Renderer: Texture marked for update but image is undefined.");
        } else if (image.complete === false) {
          console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");
        } else {
          if (texture2.images) {
            const images = [];
            for (const image2 of texture2.images) {
              images.push(image2);
            }
            options.images = images;
          } else {
            options.image = image;
          }
          if (textureData.isDefaultTexture === void 0 || textureData.isDefaultTexture === true) {
            backend.createTexture(texture2, options);
            textureData.isDefaultTexture = false;
          }
          backend.updateTexture(texture2, options);
          if (options.needsMipmaps && texture2.mipmaps.length === 0)
            backend.generateMipmaps(texture2);
        }
      } else {
        backend.createDefaultTexture(texture2);
        textureData.isDefaultTexture = true;
      }
    }
    if (textureData.initialized !== true) {
      textureData.initialized = true;
      this.info.memory.textures++;
      const onDispose = () => {
        texture2.removeEventListener("dispose", onDispose);
        this._destroyTexture(texture2);
        this.info.memory.textures--;
      };
      texture2.addEventListener("dispose", onDispose);
    }
    textureData.version = texture2.version;
  }
  getSize(texture2, target = _size) {
    let image = texture2.images ? texture2.images[0] : texture2.image;
    if (image) {
      if (image.image !== void 0)
        image = image.image;
      target.width = image.width;
      target.height = image.height;
      target.depth = texture2.isCubeTexture ? 6 : image.depth || 1;
    } else {
      target.width = target.height = target.depth = 1;
    }
    return target;
  }
  getMipLevels(texture2, width, height) {
    let mipLevelCount;
    if (texture2.isCompressedTexture) {
      mipLevelCount = texture2.mipmaps.length;
    } else {
      mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
    }
    return mipLevelCount;
  }
  needsMipmaps(texture2) {
    if (this.isEnvironmentTexture(texture2))
      return true;
    return texture2.isCompressedTexture === true || texture2.minFilter !== NearestFilter && texture2.minFilter !== LinearFilter;
  }
  isEnvironmentTexture(texture2) {
    const mapping = texture2.mapping;
    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || (mapping === CubeReflectionMapping || mapping === CubeRefractionMapping);
  }
  _destroyTexture(texture2) {
    this.backend.destroySampler(texture2);
    this.backend.destroyTexture(texture2);
    this.delete(texture2);
  }
};
var Textures_default = Textures;

// node_modules/three/examples/jsm/renderers/common/Color4.js
var Color4 = class extends Color {
  constructor(r, g, b, a = 1) {
    super(r, g, b);
    this.a = a;
  }
  set(r, g, b, a = 1) {
    this.a = a;
    return super.set(r, g, b);
  }
  copy(color) {
    if (color.a !== void 0)
      this.a = color.a;
    return super.copy(color);
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
};
var Color4_default = Color4;

// node_modules/three/examples/jsm/renderers/common/Background.js
var _clearColor = new Color4_default();
var Background = class extends DataMap_default {
  constructor(renderer, nodes) {
    super();
    this.renderer = renderer;
    this.nodes = nodes;
  }
  update(scene, renderList, renderContext) {
    const renderer = this.renderer;
    const background = this.nodes.getBackgroundNode(scene) || scene.background;
    let forceClear = false;
    if (background === null) {
      renderer._clearColor.getRGB(_clearColor, this.renderer.currentColorSpace);
      _clearColor.a = renderer._clearColor.a;
    } else if (background.isColor === true) {
      background.getRGB(_clearColor, this.renderer.currentColorSpace);
      _clearColor.a = 1;
      forceClear = true;
    } else if (background.isNode === true) {
      const sceneData = this.get(scene);
      const backgroundNode = background;
      _clearColor.copy(renderer._clearColor);
      let backgroundMesh = sceneData.backgroundMesh;
      if (backgroundMesh === void 0) {
        const backgroundMeshNode = context(vec4(backgroundNode), {
          // @TODO: Add Texture2D support using node context
          getUV: () => normalWorld,
          getTextureLevel: () => backgroundBlurriness
        }).mul(backgroundIntensity);
        let viewProj = modelViewProjection();
        viewProj = viewProj.setZ(viewProj.w);
        const nodeMaterial = new NodeMaterial_default();
        nodeMaterial.side = BackSide;
        nodeMaterial.depthTest = false;
        nodeMaterial.depthWrite = false;
        nodeMaterial.fog = false;
        nodeMaterial.vertexNode = viewProj;
        nodeMaterial.fragmentNode = backgroundMeshNode;
        sceneData.backgroundMeshNode = backgroundMeshNode;
        sceneData.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);
        backgroundMesh.frustumCulled = false;
        backgroundMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
      }
      const backgroundCacheKey = backgroundNode.getCacheKey();
      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {
        sceneData.backgroundMeshNode.node = vec4(backgroundNode);
        backgroundMesh.material.needsUpdate = true;
        sceneData.backgroundCacheKey = backgroundCacheKey;
      }
      renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null);
    } else {
      console.error("THREE.Renderer: Unsupported background configuration.", background);
    }
    if (renderer.autoClear === true || forceClear === true) {
      _clearColor.multiplyScalar(_clearColor.a);
      const clearColorValue = renderContext.clearColorValue;
      clearColorValue.r = _clearColor.r;
      clearColorValue.g = _clearColor.g;
      clearColorValue.b = _clearColor.b;
      clearColorValue.a = _clearColor.a;
      renderContext.depthClearValue = renderer._clearDepth;
      renderContext.stencilClearValue = renderer._clearStencil;
      renderContext.clearColor = renderer.autoClearColor === true;
      renderContext.clearDepth = renderer.autoClearDepth === true;
      renderContext.clearStencil = renderer.autoClearStencil === true;
    } else {
      renderContext.clearColor = false;
      renderContext.clearDepth = false;
      renderContext.clearStencil = false;
    }
  }
};
var Background_default = Background;

// node_modules/three/examples/jsm/renderers/common/nodes/NodeBuilderState.js
var NodeBuilderState = class {
  constructor(vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes) {
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.computeShader = computeShader;
    this.nodeAttributes = nodeAttributes;
    this.bindings = bindings;
    this.updateNodes = updateNodes;
    this.updateBeforeNodes = updateBeforeNodes;
    this.usedTimes = 0;
  }
  createBindings() {
    const bindingsArray = [];
    for (const instanceBinding of this.bindings) {
      let binding = instanceBinding;
      if (instanceBinding.shared !== true) {
        binding = instanceBinding.clone();
      }
      bindingsArray.push(binding);
    }
    return bindingsArray;
  }
};
var NodeBuilderState_default = NodeBuilderState;

// node_modules/three/examples/jsm/renderers/common/nodes/Nodes.js
var Nodes = class extends DataMap_default {
  constructor(renderer, backend) {
    super();
    this.renderer = renderer;
    this.backend = backend;
    this.nodeFrame = new NodeFrame_default();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
    this.callHashCache = new ChainMap();
    this.groupsData = new ChainMap();
  }
  updateGroup(nodeUniformsGroup) {
    const groupNode = nodeUniformsGroup.groupNode;
    const name = groupNode.name;
    if (name === objectGroup.name)
      return true;
    if (name === renderGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const renderId = this.nodeFrame.renderId;
      if (uniformsGroupData.renderId !== renderId) {
        uniformsGroupData.renderId = renderId;
        return true;
      }
      return false;
    }
    if (name === frameGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const frameId = this.nodeFrame.frameId;
      if (uniformsGroupData.frameId !== frameId) {
        uniformsGroupData.frameId = frameId;
        return true;
      }
      return false;
    }
    const groupChain = [groupNode, nodeUniformsGroup];
    let groupData = this.groupsData.get(groupChain);
    if (groupData === void 0)
      this.groupsData.set(groupChain, groupData = {});
    if (groupData.version !== groupNode.version) {
      groupData.version = groupNode.version;
      return true;
    }
    return false;
  }
  getForRenderCacheKey(renderObject) {
    return renderObject.initialCacheKey;
  }
  getForRender(renderObject) {
    const renderObjectData = this.get(renderObject);
    let nodeBuilderState = renderObjectData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const { nodeBuilderCache } = this;
      const cacheKey = this.getForRenderCacheKey(renderObject);
      nodeBuilderState = nodeBuilderCache.get(cacheKey);
      if (nodeBuilderState === void 0) {
        const nodeBuilder = this.backend.createNodeBuilder(renderObject.object, this.renderer, renderObject.scene);
        nodeBuilder.material = renderObject.material;
        nodeBuilder.context.material = renderObject.material;
        nodeBuilder.lightsNode = renderObject.lightsNode;
        nodeBuilder.environmentNode = this.getEnvironmentNode(renderObject.scene);
        nodeBuilder.fogNode = this.getFogNode(renderObject.scene);
        nodeBuilder.toneMappingNode = this.getToneMappingNode();
        nodeBuilder.build();
        nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
        nodeBuilderCache.set(cacheKey, nodeBuilderState);
      }
      nodeBuilderState.usedTimes++;
      renderObjectData.nodeBuilderState = nodeBuilderState;
    }
    return nodeBuilderState;
  }
  delete(object) {
    if (object.isRenderObject) {
      const nodeBuilderState = this.get(object).nodeBuilderState;
      nodeBuilderState.usedTimes--;
      if (nodeBuilderState.usedTimes === 0) {
        this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
      }
    }
    return super.delete(object);
  }
  getForCompute(computeNode) {
    const computeData = this.get(computeNode);
    let nodeBuilderState = computeData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);
      nodeBuilder.build();
      nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
      computeData.nodeBuilderState = nodeBuilder;
    }
    return nodeBuilderState;
  }
  _createNodeBuilderState(nodeBuilder) {
    return new NodeBuilderState_default(
      nodeBuilder.vertexShader,
      nodeBuilder.fragmentShader,
      nodeBuilder.computeShader,
      nodeBuilder.getAttributesArray(),
      nodeBuilder.getBindings(),
      nodeBuilder.updateNodes,
      nodeBuilder.updateBeforeNodes
    );
  }
  getEnvironmentNode(scene) {
    return scene.environmentNode || this.get(scene).environmentNode || null;
  }
  getBackgroundNode(scene) {
    return scene.backgroundNode || this.get(scene).backgroundNode || null;
  }
  getFogNode(scene) {
    return scene.fogNode || this.get(scene).fogNode || null;
  }
  getToneMappingNode() {
    if (this.isToneMappingState === false)
      return null;
    return this.renderer.toneMappingNode || this.get(this.renderer).toneMappingNode || null;
  }
  getCacheKey(scene, lightsNode) {
    const chain = [scene, lightsNode];
    const callId = this.renderer.info.calls;
    let cacheKeyData = this.callHashCache.get(chain);
    if (cacheKeyData === void 0 || cacheKeyData.callId !== callId) {
      const environmentNode = this.getEnvironmentNode(scene);
      const fogNode = this.getFogNode(scene);
      const toneMappingNode = this.getToneMappingNode();
      const cacheKey = [];
      if (lightsNode)
        cacheKey.push(lightsNode.getCacheKey());
      if (environmentNode)
        cacheKey.push(environmentNode.getCacheKey());
      if (fogNode)
        cacheKey.push(fogNode.getCacheKey());
      if (toneMappingNode)
        cacheKey.push(toneMappingNode.getCacheKey());
      cacheKeyData = {
        callId,
        cacheKey: cacheKey.join(",")
      };
      this.callHashCache.set(chain, cacheKeyData);
    }
    return cacheKeyData.cacheKey;
  }
  updateScene(scene) {
    this.updateEnvironment(scene);
    this.updateFog(scene);
    this.updateBackground(scene);
    this.updateToneMapping();
  }
  get isToneMappingState() {
    const renderer = this.renderer;
    const renderTarget = renderer.getRenderTarget();
    return renderTarget && renderTarget.isCubeRenderTarget ? false : true;
  }
  updateToneMapping() {
    const renderer = this.renderer;
    const rendererData = this.get(renderer);
    const rendererToneMapping = renderer.toneMapping;
    if (this.isToneMappingState && rendererToneMapping !== NoToneMapping) {
      if (rendererData.toneMapping !== rendererToneMapping) {
        const rendererToneMappingNode = rendererData.rendererToneMappingNode || toneMapping(rendererToneMapping, reference("toneMappingExposure", "float", renderer));
        rendererToneMappingNode.toneMapping = rendererToneMapping;
        rendererData.rendererToneMappingNode = rendererToneMappingNode;
        rendererData.toneMappingNode = rendererToneMappingNode;
        rendererData.toneMapping = rendererToneMapping;
      }
    } else {
      delete rendererData.toneMappingNode;
      delete rendererData.toneMapping;
    }
  }
  updateBackground(scene) {
    const sceneData = this.get(scene);
    const background = scene.background;
    if (background) {
      if (sceneData.background !== background) {
        let backgroundNode = null;
        if (background.isCubeTexture === true) {
          backgroundNode = cubeTexture(background, normalWorld);
        } else if (background.isTexture === true) {
          let nodeUV = null;
          if (background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping) {
            nodeUV = equirectUV();
          } else {
            nodeUV = viewportBottomLeft;
          }
          backgroundNode = texture(background, nodeUV).setUpdateMatrix(true);
        } else if (background.isColor !== true) {
          console.error("WebGPUNodes: Unsupported background configuration.", background);
        }
        sceneData.backgroundNode = backgroundNode;
        sceneData.background = background;
      }
    } else if (sceneData.backgroundNode) {
      delete sceneData.backgroundNode;
      delete sceneData.background;
    }
  }
  updateFog(scene) {
    const sceneData = this.get(scene);
    const fog = scene.fog;
    if (fog) {
      if (sceneData.fog !== fog) {
        let fogNode = null;
        if (fog.isFogExp2) {
          fogNode = densityFog(reference("color", "color", fog), reference("density", "float", fog));
        } else if (fog.isFog) {
          fogNode = rangeFog(reference("color", "color", fog), reference("near", "float", fog), reference("far", "float", fog));
        } else {
          console.error("WebGPUNodes: Unsupported fog configuration.", fog);
        }
        sceneData.fogNode = fogNode;
        sceneData.fog = fog;
      }
    } else {
      delete sceneData.fogNode;
      delete sceneData.fog;
    }
  }
  updateEnvironment(scene) {
    const sceneData = this.get(scene);
    const environment = scene.environment;
    if (environment) {
      if (sceneData.environment !== environment) {
        let environmentNode = null;
        if (environment.isCubeTexture === true) {
          environmentNode = cubeTexture(environment);
        } else if (environment.isTexture === true) {
          environmentNode = texture(environment);
        } else {
          console.error("Nodes: Unsupported environment configuration.", environment);
        }
        sceneData.environmentNode = environmentNode;
        sceneData.environment = environment;
      }
    } else if (sceneData.environmentNode) {
      delete sceneData.environmentNode;
      delete sceneData.environment;
    }
  }
  getNodeFrame(renderer = this.renderer, scene = null, object = null, camera = null, material = null) {
    const nodeFrame = this.nodeFrame;
    nodeFrame.renderer = renderer;
    nodeFrame.scene = scene;
    nodeFrame.object = object;
    nodeFrame.camera = camera;
    nodeFrame.material = material;
    return nodeFrame;
  }
  getNodeFrameForRender(renderObject) {
    return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);
  }
  updateBefore(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateBeforeNodes) {
      nodeFrame.updateBeforeNode(node);
    }
  }
  updateForCompute(computeNode) {
    const nodeFrame = this.getNodeFrame();
    const nodeBuilder = this.getForCompute(computeNode);
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  updateForRender(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  dispose() {
    super.dispose();
    this.nodeFrame = new NodeFrame_default();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
  }
};
var Nodes_default = Nodes;

// node_modules/three/examples/jsm/renderers/common/Renderer.js
var _scene = new Scene();
var _drawingBufferSize = new Vector2();
var _screen = new Vector4();
var _frustum = new Frustum();
var _projScreenMatrix = new Matrix4();
var _vector3 = new Vector3();
var Renderer = class {
  constructor(backend, parameters = {}) {
    this.isRenderer = true;
    const {
      logarithmicDepthBuffer = false
    } = parameters;
    this.domElement = backend.getDomElement();
    this.backend = backend;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.logarithmicDepthBuffer = logarithmicDepthBuffer;
    this.outputColorSpace = SRGBColorSpace;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    this.sortObjects = true;
    this.depth = true;
    this.stencil = true;
    this.info = new Info_default();
    this._pixelRatio = 1;
    this._width = this.domElement.width;
    this._height = this.domElement.height;
    this._viewport = new Vector4(0, 0, this._width, this._height);
    this._scissor = new Vector4(0, 0, this._width, this._height);
    this._scissorTest = false;
    this._properties = null;
    this._attributes = null;
    this._geometries = null;
    this._nodes = null;
    this._animation = null;
    this._bindings = null;
    this._objects = null;
    this._pipelines = null;
    this._renderLists = null;
    this._renderContexts = null;
    this._textures = null;
    this._background = null;
    this._currentRenderContext = null;
    this._opaqueSort = null;
    this._transparentSort = null;
    this._clearColor = new Color4_default(0);
    this._clearDepth = 1;
    this._clearStencil = 0;
    this._renderTarget = null;
    this._activeCubeFace = 0;
    this._activeMipmapLevel = 0;
    this._renderObjectFunction = null;
    this._currentRenderObjectFunction = null;
    this._initialized = false;
    this._initPromise = null;
    this.shadowMap = {
      enabled: false,
      type: null
    };
    this.xr = {
      enabled: false
    };
  }
  async init() {
    if (this._initialized) {
      throw new Error("Renderer: Backend has already been initialized.");
    }
    if (this._initPromise !== null) {
      return this._initPromise;
    }
    this._initPromise = new Promise(async (resolve, reject) => {
      const backend = this.backend;
      try {
        await backend.init(this);
      } catch (error) {
        reject(error);
        return;
      }
      this._nodes = new Nodes_default(this, backend);
      this._animation = new Animation_default(this._nodes, this.info);
      this._attributes = new Attributes_default(backend);
      this._background = new Background_default(this, this._nodes);
      this._geometries = new Geometries_default(this._attributes, this.info);
      this._textures = new Textures_default(backend, this.info);
      this._pipelines = new Pipelines_default(backend, this._nodes);
      this._bindings = new Bindings_default(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);
      this._objects = new RenderObjects_default(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);
      this._renderLists = new RenderLists_default();
      this._renderContexts = new RenderContexts_default();
      this._initialized = true;
      resolve();
    });
    return this._initPromise;
  }
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  async compile() {
    console.warn("THREE.Renderer: .compile() is not implemented yet.");
  }
  async render(scene, camera) {
    if (this._initialized === false)
      await this.init();
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderContext = this._currentRenderContext;
    const previousRenderObjectFunction = this._currentRenderObjectFunction;
    const sceneRef = scene.isScene === true ? scene : _scene;
    const renderTarget = this._renderTarget;
    const renderContext = this._renderContexts.get(scene, camera, renderTarget);
    const activeCubeFace = this._activeCubeFace;
    const activeMipmapLevel = this._activeMipmapLevel;
    this._currentRenderContext = renderContext;
    this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
    this.info.calls++;
    this.info.render.calls++;
    nodeFrame.renderId = this.info.calls;
    const coordinateSystem = this.coordinateSystem;
    if (camera.coordinateSystem !== coordinateSystem) {
      camera.coordinateSystem = coordinateSystem;
      camera.updateProjectionMatrix();
    }
    if (scene.matrixWorldAutoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
      camera.updateMatrixWorld();
    if (this.info.autoReset === true)
      this.info.reset();
    let viewport = this._viewport;
    let scissor = this._scissor;
    let pixelRatio = this._pixelRatio;
    if (renderTarget !== null) {
      viewport = renderTarget.viewport;
      scissor = renderTarget.scissor;
      pixelRatio = 1;
    }
    this.getDrawingBufferSize(_drawingBufferSize);
    _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);
    const minDepth = viewport.minDepth === void 0 ? 0 : viewport.minDepth;
    const maxDepth = viewport.maxDepth === void 0 ? 1 : viewport.maxDepth;
    renderContext.viewportValue.copy(viewport).multiplyScalar(pixelRatio).floor();
    renderContext.viewportValue.width >>= activeMipmapLevel;
    renderContext.viewportValue.height >>= activeMipmapLevel;
    renderContext.viewportValue.minDepth = minDepth;
    renderContext.viewportValue.maxDepth = maxDepth;
    renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;
    renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();
    renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals(_screen) === false;
    renderContext.scissorValue.width >>= activeMipmapLevel;
    renderContext.scissorValue.height >>= activeMipmapLevel;
    renderContext.depth = this.depth;
    renderContext.stencil = this.stencil;
    sceneRef.onBeforeRender(this, scene, camera, renderTarget);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);
    const renderList = this._renderLists.get(scene, camera);
    renderList.begin();
    this._projectObject(scene, camera, 0, renderList);
    renderList.finish();
    if (this.sortObjects === true) {
      renderList.sort(this._opaqueSort, this._transparentSort);
    }
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
      renderContext.width = renderTargetData.width;
      renderContext.height = renderTargetData.height;
      renderContext.renderTarget = renderTarget;
    } else {
      renderContext.textures = null;
      renderContext.depthTexture = null;
      renderContext.width = this.domElement.width;
      renderContext.height = this.domElement.height;
    }
    renderContext.width >>= activeMipmapLevel;
    renderContext.height >>= activeMipmapLevel;
    renderContext.activeCubeFace = activeCubeFace;
    renderContext.activeMipmapLevel = activeMipmapLevel;
    renderContext.occlusionQueryCount = renderList.occlusionQueryCount;
    this._nodes.updateScene(sceneRef);
    this._background.update(sceneRef, renderList, renderContext);
    this.backend.beginRender(renderContext);
    const opaqueObjects = renderList.opaque;
    const transparentObjects = renderList.transparent;
    const lightsNode = renderList.lightsNode;
    if (opaqueObjects.length > 0)
      this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
    if (transparentObjects.length > 0)
      this._renderObjects(transparentObjects, camera, sceneRef, lightsNode);
    this.backend.finishRender(renderContext);
    nodeFrame.renderId = previousRenderId;
    this._currentRenderContext = previousRenderContext;
    this._currentRenderObjectFunction = previousRenderObjectFunction;
    sceneRef.onAfterRender(this, scene, camera, renderTarget);
  }
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  async setAnimationLoop(callback) {
    if (this._initialized === false)
      await this.init();
    this._animation.setAnimationLoop(callback);
  }
  getArrayBuffer(attribute) {
    console.warn("THREE.Renderer: getArrayBuffer() is deprecated. Use getArrayBufferAsync() instead.");
    return this.getArrayBufferAsync(attribute);
  }
  async getArrayBufferAsync(attribute) {
    return await this.backend.getArrayBufferAsync(attribute);
  }
  getContext() {
    return this._context;
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  getDrawingBufferSize(target) {
    return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  getSize(target) {
    return target.set(this._width, this._height);
  }
  setPixelRatio(value = 1) {
    this._pixelRatio = value;
    this.setSize(this._width, this._height, false);
  }
  setDrawingBufferSize(width, height, pixelRatio) {
    this._width = width;
    this._height = height;
    this._pixelRatio = pixelRatio;
    this.domElement.width = Math.floor(width * pixelRatio);
    this.domElement.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
    if (this._initialized)
      this.backend.updateSize();
  }
  setSize(width, height, updateStyle = true) {
    this._width = width;
    this._height = height;
    this.domElement.width = Math.floor(width * this._pixelRatio);
    this.domElement.height = Math.floor(height * this._pixelRatio);
    if (updateStyle === true) {
      this.domElement.style.width = width + "px";
      this.domElement.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
    if (this._initialized)
      this.backend.updateSize();
  }
  setOpaqueSort(method) {
    this._opaqueSort = method;
  }
  setTransparentSort(method) {
    this._transparentSort = method;
  }
  getScissor(target) {
    const scissor = this._scissor;
    target.x = scissor.x;
    target.y = scissor.y;
    target.width = scissor.width;
    target.height = scissor.height;
    return target;
  }
  setScissor(x, y, width, height) {
    const scissor = this._scissor;
    if (x.isVector4) {
      scissor.copy(x);
    } else {
      scissor.set(x, y, width, height);
    }
  }
  getScissorTest() {
    return this._scissorTest;
  }
  setScissorTest(boolean) {
    this._scissorTest = boolean;
  }
  getViewport(target) {
    return target.copy(this._viewport);
  }
  setViewport(x, y, width, height, minDepth = 0, maxDepth = 1) {
    const viewport = this._viewport;
    if (x.isVector4) {
      viewport.copy(x);
    } else {
      viewport.set(x, y, width, height);
    }
    viewport.minDepth = minDepth;
    viewport.maxDepth = maxDepth;
  }
  getClearColor(target) {
    return target.copy(this._clearColor);
  }
  setClearColor(color, alpha = 1) {
    this._clearColor.set(color);
    this._clearColor.a = alpha;
  }
  getClearAlpha() {
    return this._clearColor.a;
  }
  setClearAlpha(alpha) {
    this._clearColor.a = alpha;
  }
  getClearDepth() {
    return this._clearDepth;
  }
  setClearDepth(depth) {
    this._clearDepth = depth;
  }
  getClearStencil() {
    return this._clearStencil;
  }
  setClearStencil(stencil) {
    this._clearStencil = stencil;
  }
  isOccluded(object) {
    const renderContext = this._currentRenderContext;
    return renderContext && this.backend.isOccluded(renderContext, object);
  }
  clear(color = true, depth = true, stencil = true) {
    let renderTargetData = null;
    const renderTarget = this._renderTarget;
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget);
      renderTargetData = this._textures.get(renderTarget);
    }
    this.backend.clear(color, depth, stencil, renderTargetData);
  }
  clearColor() {
    this.clear(true, false, false);
  }
  clearDepth() {
    this.clear(false, true, false);
  }
  clearStencil() {
    this.clear(false, false, true);
  }
  get currentColorSpace() {
    const renderTarget = this._renderTarget;
    if (renderTarget !== null) {
      const texture2 = renderTarget.texture;
      return (Array.isArray(texture2) ? texture2[0] : texture2).colorSpace;
    }
    return this.outputColorSpace;
  }
  dispose() {
    this.info.dispose();
    this._animation.dispose();
    this._objects.dispose();
    this._properties.dispose();
    this._pipelines.dispose();
    this._nodes.dispose();
    this._bindings.dispose();
    this._renderLists.dispose();
    this._renderContexts.dispose();
    this._textures.dispose();
    this.setRenderTarget(null);
    this.setAnimationLoop(null);
  }
  setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    this._renderTarget = renderTarget;
    this._activeCubeFace = activeCubeFace;
    this._activeMipmapLevel = activeMipmapLevel;
  }
  getRenderTarget() {
    return this._renderTarget;
  }
  setRenderObjectFunction(renderObjectFunction) {
    this._renderObjectFunction = renderObjectFunction;
  }
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  async compute(computeNodes) {
    if (this._initialized === false)
      await this.init();
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    this.info.calls++;
    this.info.compute.calls++;
    nodeFrame.renderId = this.info.calls;
    const backend = this.backend;
    const pipelines = this._pipelines;
    const bindings = this._bindings;
    const nodes = this._nodes;
    const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
    if (computeList[0] === void 0 || computeList[0].isComputeNode !== true) {
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    }
    backend.beginCompute(computeNodes);
    for (const computeNode of computeList) {
      if (pipelines.has(computeNode) === false) {
        const dispose = () => {
          computeNode.removeEventListener("dispose", dispose);
          pipelines.delete(computeNode);
          bindings.delete(computeNode);
          nodes.delete(computeNode);
        };
        computeNode.addEventListener("dispose", dispose);
        computeNode.onInit({ renderer: this });
      }
      nodes.updateForCompute(computeNode);
      bindings.updateForCompute(computeNode);
      const computeBindings = bindings.getForCompute(computeNode);
      const computePipeline = pipelines.getForCompute(computeNode, computeBindings);
      backend.compute(computeNodes, computeNode, computeBindings, computePipeline);
    }
    backend.finishCompute(computeNodes);
    nodeFrame.renderId = previousRenderId;
  }
  hasFeature(name) {
    return this.backend.hasFeature(name);
  }
  copyFramebufferToTexture(framebufferTexture) {
    const renderContext = this._currentRenderContext;
    this._textures.updateTexture(framebufferTexture);
    this.backend.copyFramebufferToTexture(framebufferTexture, renderContext);
  }
  readRenderTargetPixelsAsync(renderTarget, x, y, width, height) {
    return this.backend.copyTextureToBuffer(renderTarget.texture, x, y, width, height);
  }
  _projectObject(object, camera, groupOrder, renderList) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        renderList.pushLight(object);
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (this.sortObjects === true) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const geometry = object.geometry;
          const material = object.material;
          if (material.visible) {
            renderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isLineLoop) {
        console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          const geometry = object.geometry;
          const material = object.material;
          if (this.sortObjects === true) {
            if (geometry.boundingSphere === null)
              geometry.computeBoundingSphere();
            _vector3.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                renderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            renderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this._projectObject(children[i], camera, groupOrder, renderList);
    }
  }
  _renderObjects(renderList, camera, scene, lightsNode) {
    for (let i = 0, il = renderList.length; i < il; i++) {
      const renderItem = renderList[i];
      const { object, geometry, material, group } = renderItem;
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            const vp = camera2.viewport;
            const minDepth = vp.minDepth === void 0 ? 0 : vp.minDepth;
            const maxDepth = vp.maxDepth === void 0 ? 1 : vp.maxDepth;
            const viewportValue = this._currentRenderContext.viewportValue;
            viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();
            viewportValue.minDepth = minDepth;
            viewportValue.maxDepth = maxDepth;
            this.backend.updateViewport(this._currentRenderContext);
            this._currentRenderObjectFunction(object, scene, camera2, geometry, material, group, lightsNode);
          }
        }
      } else {
        this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode);
      }
    }
  }
  renderObject(object, scene, camera, geometry, material, group, lightsNode) {
    let overridePositionNode;
    object.onBeforeRender(this, scene, camera, geometry, material, group);
    material.onBeforeRender(this, scene, camera, geometry, material, group);
    if (scene.overrideMaterial !== null) {
      const overrideMaterial = scene.overrideMaterial;
      if (material.positionNode && material.positionNode.isNode) {
        overridePositionNode = overrideMaterial.positionNode;
        overrideMaterial.positionNode = material.positionNode;
      }
      material = overrideMaterial;
    }
    if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
      material.side = BackSide;
      this._renderObjectDirect(object, material, scene, camera, lightsNode, "backSide");
      material.side = FrontSide;
      this._renderObjectDirect(object, material, scene, camera, lightsNode);
      material.side = DoubleSide;
    } else {
      this._renderObjectDirect(object, material, scene, camera, lightsNode);
    }
    if (overridePositionNode !== void 0) {
      scene.overrideMaterial.positionNode = overridePositionNode;
    }
    object.onAfterRender(this, scene, camera, geometry, material, group);
  }
  _renderObjectDirect(object, material, scene, camera, lightsNode, passId) {
    const renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, passId);
    this._nodes.updateBefore(renderObject);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    this._nodes.updateForRender(renderObject);
    this._geometries.updateForRender(renderObject);
    this._bindings.updateForRender(renderObject);
    this._pipelines.updateForRender(renderObject);
    this.backend.draw(renderObject, this.info);
  }
};
var Renderer_default = Renderer;

// node_modules/three/examples/jsm/renderers/common/Binding.js
var Binding = class {
  constructor(name = "") {
    this.name = name;
    this.visibility = 0;
  }
  setVisibility(visibility) {
    this.visibility |= visibility;
  }
  clone() {
    return Object.assign(new this.constructor(), this);
  }
};
var Binding_default = Binding;

// node_modules/three/examples/jsm/renderers/common/BufferUtils.js
function getFloatLength(floatLength) {
  return floatLength + (GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;
}
function getVectorLength(count, vectorLength = 4) {
  const strideLength = getStrideLength(vectorLength);
  const floatLength = strideLength * count;
  return getFloatLength(floatLength);
}
function getStrideLength(vectorLength) {
  const strideLength = 4;
  return vectorLength + (strideLength - vectorLength % strideLength) % strideLength;
}

// node_modules/three/examples/jsm/renderers/common/Buffer.js
var Buffer = class extends Binding_default {
  constructor(name, buffer = null) {
    super(name);
    this.isBuffer = true;
    this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;
    this._buffer = buffer;
  }
  get byteLength() {
    return getFloatLength(this._buffer.byteLength);
  }
  get buffer() {
    return this._buffer;
  }
  update() {
    return true;
  }
};
var Buffer_default = Buffer;

// node_modules/three/examples/jsm/renderers/common/UniformBuffer.js
var UniformBuffer = class extends Buffer_default {
  constructor(name, buffer = null) {
    super(name, buffer);
    this.isUniformBuffer = true;
  }
};
var UniformBuffer_default = UniformBuffer;

// node_modules/three/examples/jsm/renderers/common/UniformsGroup.js
var UniformsGroup = class extends UniformBuffer_default {
  constructor(name) {
    super(name);
    this.isUniformsGroup = true;
    this.uniforms = [];
  }
  addUniform(uniform) {
    this.uniforms.push(uniform);
    return this;
  }
  removeUniform(uniform) {
    const index = this.uniforms.indexOf(uniform);
    if (index !== -1) {
      this.uniforms.splice(index, 1);
    }
    return this;
  }
  get buffer() {
    let buffer = this._buffer;
    if (buffer === null) {
      const byteLength = this.byteLength;
      buffer = new Float32Array(new ArrayBuffer(byteLength));
      this._buffer = buffer;
    }
    return buffer;
  }
  get byteLength() {
    let offset = 0;
    for (let i = 0, l = this.uniforms.length; i < l; i++) {
      const uniform = this.uniforms[i];
      const chunkOffset = offset % GPU_CHUNK_BYTES;
      const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;
      if (chunkOffset !== 0 && remainingSizeInChunk - uniform.boundary < 0) {
        offset += GPU_CHUNK_BYTES - chunkOffset;
      } else if (chunkOffset % uniform.boundary !== 0) {
        offset += chunkOffset % uniform.boundary;
      }
      uniform.offset = offset / this.bytesPerElement;
      offset += uniform.itemSize * this.bytesPerElement;
    }
    return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;
  }
  update() {
    let updated = false;
    for (const uniform of this.uniforms) {
      if (this.updateByType(uniform) === true) {
        updated = true;
      }
    }
    return updated;
  }
  updateByType(uniform) {
    if (uniform.isFloatUniform)
      return this.updateNumber(uniform);
    if (uniform.isVector2Uniform)
      return this.updateVector2(uniform);
    if (uniform.isVector3Uniform)
      return this.updateVector3(uniform);
    if (uniform.isVector4Uniform)
      return this.updateVector4(uniform);
    if (uniform.isColorUniform)
      return this.updateColor(uniform);
    if (uniform.isMatrix3Uniform)
      return this.updateMatrix3(uniform);
    if (uniform.isMatrix4Uniform)
      return this.updateMatrix4(uniform);
    console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", uniform);
  }
  updateNumber(uniform) {
    let updated = false;
    const a = this.buffer;
    const v = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset] !== v) {
      a[offset] = v;
      updated = true;
    }
    return updated;
  }
  updateVector2(uniform) {
    let updated = false;
    const a = this.buffer;
    const v = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y) {
      a[offset + 0] = v.x;
      a[offset + 1] = v.y;
      updated = true;
    }
    return updated;
  }
  updateVector3(uniform) {
    let updated = false;
    const a = this.buffer;
    const v = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z) {
      a[offset + 0] = v.x;
      a[offset + 1] = v.y;
      a[offset + 2] = v.z;
      updated = true;
    }
    return updated;
  }
  updateVector4(uniform) {
    let updated = false;
    const a = this.buffer;
    const v = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z || a[offset + 4] !== v.w) {
      a[offset + 0] = v.x;
      a[offset + 1] = v.y;
      a[offset + 2] = v.z;
      a[offset + 3] = v.w;
      updated = true;
    }
    return updated;
  }
  updateColor(uniform) {
    let updated = false;
    const a = this.buffer;
    const c = uniform.getValue();
    const offset = uniform.offset;
    if (a[offset + 0] !== c.r || a[offset + 1] !== c.g || a[offset + 2] !== c.b) {
      a[offset + 0] = c.r;
      a[offset + 1] = c.g;
      a[offset + 2] = c.b;
      updated = true;
    }
    return updated;
  }
  updateMatrix3(uniform) {
    let updated = false;
    const a = this.buffer;
    const e = uniform.getValue().elements;
    const offset = uniform.offset;
    if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] || a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] || a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {
      a[offset + 0] = e[0];
      a[offset + 1] = e[1];
      a[offset + 2] = e[2];
      a[offset + 4] = e[3];
      a[offset + 5] = e[4];
      a[offset + 6] = e[5];
      a[offset + 8] = e[6];
      a[offset + 9] = e[7];
      a[offset + 10] = e[8];
      updated = true;
    }
    return updated;
  }
  updateMatrix4(uniform) {
    let updated = false;
    const a = this.buffer;
    const e = uniform.getValue().elements;
    const offset = uniform.offset;
    if (arraysEqual(a, e, offset) === false) {
      a.set(e, offset);
      updated = true;
    }
    return updated;
  }
};
function arraysEqual(a, b, offset) {
  for (let i = 0, l = b.length; i < l; i++) {
    if (a[offset + i] !== b[i])
      return false;
  }
  return true;
}
var UniformsGroup_default = UniformsGroup;

// node_modules/three/examples/jsm/renderers/common/nodes/NodeUniformsGroup.js
var id3 = 0;
var NodeUniformsGroup = class extends UniformsGroup_default {
  constructor(name, groupNode) {
    super(name);
    this.id = id3++;
    this.groupNode = groupNode;
    this.isNodeUniformsGroup = true;
  }
  get shared() {
    return this.groupNode.shared;
  }
  getNodes() {
    const nodes = [];
    for (const uniform of this.uniforms) {
      const node = uniform.nodeUniform.node;
      if (!node)
        throw new Error("NodeUniformsGroup: Uniform has no node.");
      nodes.push(node);
    }
    return nodes;
  }
};
var NodeUniformsGroup_default = NodeUniformsGroup;

// node_modules/three/examples/jsm/renderers/common/SampledTexture.js
var id4 = 0;
var SampledTexture = class extends Binding_default {
  constructor(name, texture2) {
    super(name);
    this.id = id4++;
    this.texture = texture2;
    this.version = texture2 ? texture2.version : 0;
    this.store = false;
    this.isSampledTexture = true;
  }
  get needsBindingsUpdate() {
    const { texture: texture2, version } = this;
    return texture2.isVideoTexture ? true : version !== texture2.version;
  }
  update() {
    const { texture: texture2, version } = this;
    if (version !== texture2.version) {
      this.version = texture2.version;
      return true;
    }
    return false;
  }
};

// node_modules/three/examples/jsm/renderers/common/nodes/NodeSampledTexture.js
var NodeSampledTexture = class extends SampledTexture {
  constructor(name, textureNode) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
  }
  get needsBindingsUpdate() {
    return this.textureNode.value !== this.texture || super.needsBindingsUpdate;
  }
  update() {
    const { textureNode } = this;
    if (this.texture !== textureNode.value) {
      this.texture = textureNode.value;
      return true;
    }
    return super.update();
  }
};
var NodeSampledCubeTexture = class extends NodeSampledTexture {
  constructor(name, textureNode) {
    super(name, textureNode);
    this.isSampledCubeTexture = true;
  }
};

// node_modules/three/examples/jsm/renderers/webgl/nodes/GLSLNodeBuilder.js
var glslMethods = {
  [MathNode_default.ATAN2]: "atan",
  textureDimensions: "textureSize"
};
var precisionLib = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
var supports = {
  instance: true
};
var defaultPrecisions = `
precision highp float;
precision highp int;
precision mediump sampler2DArray;
precision lowp sampler2DShadow;
`;
var GLSLNodeBuilder = class extends NodeBuilder_default {
  constructor(object, renderer, scene = null) {
    super(object, renderer, new GLSLNodeParser_default(), scene);
    this.uniformGroups = {};
  }
  getMethod(method) {
    return glslMethods[method] || method;
  }
  getPropertyName(node, shaderStage) {
    if (node.isOutputStructVar)
      return "";
    return super.getPropertyName(node, shaderStage);
  }
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(this.getType(input.type) + " " + input.name);
    }
    const code = `${this.getType(layout.type)} ${layout.name}( ${parameters.join(", ")} ) {

	${flowData.vars}

${flowData.code}
	return ${flowData.result};

}`;
    return code;
  }
  generateTextureLoad(texture2, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = "0") {
    if (depthSnippet) {
      return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
    } else {
      return `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
    }
  }
  generateTexture(texture2, textureProperty, uvSnippet, depthSnippet) {
    if (texture2.isTextureCube) {
      return `textureCube( ${textureProperty}, ${uvSnippet} )`;
    } else if (texture2.isDepthTexture) {
      return `texture( ${textureProperty}, ${uvSnippet} ).x`;
    } else {
      if (depthSnippet)
        uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
      return `texture( ${textureProperty}, ${uvSnippet} )`;
    }
  }
  generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet) {
    return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
  }
  generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
    } else {
      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
    }
  }
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        if (variable.isOutputStructVar)
          continue;
        snippets.push(`${this.getVar(variable.type, variable.name)};`);
      }
    }
    return snippets.join("\n	");
  }
  getUniforms(shaderStage) {
    const uniforms = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const uniformGroups = {};
    for (const uniform of uniforms) {
      let snippet = null;
      let group = false;
      if (uniform.type === "texture") {
        const texture2 = uniform.node.value;
        if (texture2.compareFunction) {
          snippet = `sampler2DShadow ${uniform.name};`;
        } else if (texture2.isDataArrayTexture === true) {
          snippet = `sampler2DArray ${uniform.name};`;
        } else {
          snippet = `sampler2D ${uniform.name};`;
        }
      } else if (uniform.type === "cubeTexture") {
        snippet = `samplerCube ${uniform.name};`;
      } else if (uniform.type === "buffer") {
        const bufferNode = uniform.node;
        const bufferType = this.getType(bufferNode.bufferType);
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 ? bufferCount : "";
        snippet = `${bufferNode.name} {
	${bufferType} ${uniform.name}[${bufferCountSnippet}];
};
`;
      } else {
        const vectorType = this.getVectorType(uniform.type);
        snippet = `${vectorType} ${uniform.name};`;
        group = true;
      }
      const precision = uniform.node.precision;
      if (precision !== null) {
        snippet = precisionLib[precision] + " " + snippet;
      }
      if (group) {
        snippet = "	" + snippet;
        const groupName = uniform.groupNode.name;
        const groupSnippets = uniformGroups[groupName] || (uniformGroups[groupName] = []);
        groupSnippets.push(snippet);
      } else {
        snippet = "uniform " + snippet;
        bindingSnippets.push(snippet);
      }
    }
    let output = "";
    for (const name in uniformGroups) {
      const groupSnippets = uniformGroups[name];
      output += this._getGLSLUniformStruct(shaderStage + "_" + name, groupSnippets.join("\n")) + "\n";
    }
    output += bindingSnippets.join("\n");
    return output;
  }
  getTypeFromAttribute(attribute) {
    let nodeType = super.getTypeFromAttribute(attribute);
    if (/^[iu]/.test(nodeType) && attribute.gpuType !== IntType) {
      let dataAttribute = attribute;
      if (attribute.isInterleavedBufferAttribute)
        dataAttribute = attribute.data;
      const array = dataAttribute.array;
      if ((array instanceof Uint32Array || array instanceof Int32Array) === false) {
        nodeType = nodeType.slice(1);
      }
    }
    return nodeType;
  }
  getAttributes(shaderStage) {
    let snippet = "";
    if (shaderStage === "vertex") {
      const attributes = this.getAttributesArray();
      let location = 0;
      for (const attribute of attributes) {
        snippet += `layout( location = ${location++} ) in ${attribute.type} ${attribute.name};
`;
      }
    }
    return snippet;
  }
  getStructMembers(struct) {
    const snippets = [];
    const members = struct.getMemberTypes();
    for (let i = 0; i < members.length; i++) {
      const member = members[i];
      snippets.push(`layout( location = ${i} ) out ${member} m${i};`);
    }
    return snippets.join("\n");
  }
  getStructs(shaderStage) {
    const snippets = [];
    const structs = this.structs[shaderStage];
    if (structs.length === 0) {
      return "layout( location = 0 ) out vec4 fragColor;\n";
    }
    for (let index = 0, length = structs.length; index < length; index++) {
      const struct = structs[index];
      let snippet = "\n";
      snippet += this.getStructMembers(struct);
      snippet += "\n";
      snippets.push(snippet);
    }
    return snippets.join("\n\n");
  }
  getVaryings(shaderStage) {
    let snippet = "";
    const varyings = this.varyings;
    if (shaderStage === "vertex") {
      for (const varying of varyings) {
        const type = varying.type;
        const flat = type === "int" || type === "uint" ? "flat " : "";
        snippet += `${flat}${varying.needsInterpolation ? "out" : "/*out*/"} ${type} ${varying.name};
`;
      }
    } else if (shaderStage === "fragment") {
      for (const varying of varyings) {
        if (varying.needsInterpolation) {
          const type = varying.type;
          const flat = type === "int" || type === "uint" ? "flat " : "";
          snippet += `${flat}in ${type} ${varying.name};
`;
        }
      }
    }
    return snippet;
  }
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  getFragDepth() {
    return "gl_FragDepth";
  }
  isAvailable(name) {
    return supports[name] === true;
  }
  isFlipY() {
    return true;
  }
  _getGLSLUniformStruct(name, vars) {
    return `
layout( std140 ) uniform ${name} {
${vars}
};`;
  }
  _getGLSLVertexCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;
  }
  _getGLSLFragmentCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  buildCode() {
    const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    for (const shaderStage in shadersData) {
      let flow = "// code\n\n";
      flow += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow.length > 0)
            flow += "\n";
          flow += `	// flow -> ${slotName}
	`;
        }
        flow += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow += "// result\n	";
          if (shaderStage === "vertex") {
            flow += "gl_Position = ";
            flow += `${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (!node.outputNode.isOutputStructNode) {
              flow += "fragColor = ";
              flow += `${flowSlotData.result};`;
            }
          }
        }
      }
      const stageData = shadersData[shaderStage];
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      stageData.flow = flow;
    }
    if (this.material !== null) {
      this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
    } else {
      console.warn("GLSLNodeBuilder: compute shaders are not supported.");
    }
  }
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let uniformGPU = nodeData.uniformGPU;
    if (uniformGPU === void 0) {
      if (type === "texture") {
        uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node);
        this.bindings[shaderStage].push(uniformGPU);
      } else if (type === "cubeTexture") {
        uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node);
        this.bindings[shaderStage].push(uniformGPU);
      } else if (type === "buffer") {
        node.name = `NodeBuffer_${node.id}`;
        const buffer = new UniformBuffer_default(node.name, node.value);
        uniformNode.name = `buffer${node.id}`;
        this.bindings[shaderStage].push(buffer);
        uniformGPU = buffer;
      } else {
        const group = node.groupNode;
        const groupName = group.name;
        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup_default(shaderStage + "_" + groupName, group);
          uniformsStage[groupName] = uniformsGroup;
          this.bindings[shaderStage].push(uniformsGroup);
        }
        uniformGPU = this.getNodeUniform(uniformNode, type);
        uniformsGroup.addUniform(uniformGPU);
      }
      nodeData.uniformGPU = uniformGPU;
    }
    return uniformNode;
  }
  build() {
    const { object, material } = this;
    if (material !== null) {
      NodeMaterial_default.fromMaterial(material).build(this);
    } else {
      this.addFlow("compute", object);
    }
    return super.build();
  }
};
var GLSLNodeBuilder_default = GLSLNodeBuilder;

// node_modules/three/examples/jsm/renderers/common/Backend.js
var vector2 = null;
var vector4 = null;
var color4 = null;
var Backend = class {
  constructor(parameters = {}) {
    this.parameters = Object.assign({}, parameters);
    this.data = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.domElement = null;
  }
  async init(renderer) {
    this.renderer = renderer;
  }
  // render context
  begin(renderContext) {
  }
  finish(renderContext) {
  }
  // render object
  draw(renderObject, info) {
  }
  // program
  createProgram(program) {
  }
  destroyProgram(program) {
  }
  // bindings
  createBindings(renderObject) {
  }
  updateBindings(renderObject) {
  }
  // pipeline
  createRenderPipeline(renderObject) {
  }
  createComputePipeline(computeNode, pipeline) {
  }
  destroyPipeline(pipeline) {
  }
  // cache key
  needsRenderUpdate(renderObject) {
  }
  // return Boolean ( fast test )
  getRenderCacheKey(renderObject) {
  }
  // return String
  // node builder
  createNodeBuilder(renderObject) {
  }
  // return NodeBuilder (ADD IT)
  // textures
  createSampler(texture2) {
  }
  createDefaultTexture(texture2) {
  }
  createTexture(texture2) {
  }
  copyTextureToBuffer(texture2, x, y, width, height) {
  }
  // attributes
  createAttribute(attribute) {
  }
  createIndexAttribute(attribute) {
  }
  updateAttribute(attribute) {
  }
  destroyAttribute(attribute) {
  }
  // canvas
  updateSize() {
  }
  // utils
  hasFeature(name) {
  }
  // return Boolean
  getInstanceCount(renderObject) {
    const { object, geometry } = renderObject;
    return geometry.isInstancedBufferGeometry ? geometry.instanceCount : object.isInstancedMesh ? object.count : 1;
  }
  getDrawingBufferSize() {
    vector2 = vector2 || new Vector2();
    return this.renderer.getDrawingBufferSize(vector2);
  }
  getScissor() {
    vector4 = vector4 || new Vector4();
    return this.renderer.getScissor(vector4);
  }
  getClearColor() {
    const renderer = this.renderer;
    color4 = color4 || new Color4_default();
    renderer.getClearColor(color4);
    color4.getRGB(color4, this.renderer.currentColorSpace);
    return color4;
  }
  getDomElement() {
    let domElement = this.domElement;
    if (domElement === null) {
      domElement = this.parameters.canvas !== void 0 ? this.parameters.canvas : createCanvasElement();
      if ("setAttribute" in domElement)
        domElement.setAttribute("data-engine", `three.js r${REVISION} webgpu`);
      this.domElement = domElement;
    }
    return domElement;
  }
  // resource properties
  set(object, value) {
    this.data.set(object, value);
  }
  get(object) {
    let map = this.data.get(object);
    if (map === void 0) {
      map = {};
      this.data.set(object, map);
    }
    return map;
  }
  delete(object) {
    this.data.delete(object);
  }
};
var Backend_default = Backend;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLAttributeUtils.js
var WebGLAttributeUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  createAttribute(attribute, bufferType) {
    const backend = this.backend;
    const { gl } = backend;
    const array = attribute.array;
    const usage = attribute.usage || gl.STATIC_DRAW;
    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
    const bufferData = backend.get(bufferAttribute);
    let bufferGPU = bufferData.bufferGPU;
    if (bufferGPU === void 0) {
      bufferGPU = gl.createBuffer();
      gl.bindBuffer(bufferType, bufferGPU);
      gl.bufferData(bufferType, array, usage);
      gl.bindBuffer(bufferType, null);
      bufferData.bufferGPU = bufferGPU;
      bufferData.bufferType = bufferType;
      bufferData.version = bufferAttribute.version;
    }
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + array);
    }
    backend.set(attribute, {
      bufferGPU,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
      isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType
    });
  }
  updateAttribute(attribute) {
    const backend = this.backend;
    const { gl } = backend;
    const array = attribute.array;
    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
    const bufferData = backend.get(bufferAttribute);
    const bufferType = bufferData.bufferType;
    const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;
    gl.bindBuffer(bufferType, bufferData.bufferGPU);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      for (let i = 0, l = updateRanges.length; i < l; i++) {
        const range = updateRanges[i];
        gl.bufferSubData(
          bufferType,
          range.start * array.BYTES_PER_ELEMENT,
          array,
          range.start,
          range.count
        );
      }
      bufferAttribute.clearUpdateRanges();
    }
    gl.bindBuffer(bufferType, null);
    bufferData.version = bufferAttribute.version;
  }
  async getArrayBufferAsync(attribute) {
    const backend = this.backend;
    const { gl } = backend;
    const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
    const { bufferGPU } = backend.get(bufferAttribute);
    const array = attribute.array;
    const byteLength = array.byteLength;
    gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);
    const writeBuffer = gl.createBuffer();
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
    gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);
    gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);
    await backend.utils._clientWaitAsync();
    const dstBuffer = new attribute.array.constructor(array.length);
    gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);
    gl.deleteBuffer(writeBuffer);
    return dstBuffer.buffer;
  }
};
var WebGLAttributeUtils_default = WebGLAttributeUtils;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLState.js
var initialized = false;
var equationToGL;
var factorToGL;
var WebGLState = class {
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.enabled = {};
    this.currentFlipSided = null;
    this.currentCullFace = null;
    this.currentProgram = null;
    this.currentBlendingEnabled = false;
    this.currentBlending = null;
    this.currentBlendSrc = null;
    this.currentBlendDst = null;
    this.currentBlendSrcAlpha = null;
    this.currentBlendDstAlpha = null;
    this.currentPremultipledAlpha = null;
    this.currentPolygonOffsetFactor = null;
    this.currentPolygonOffsetUnits = null;
    this.currentColorMask = null;
    this.currentDepthFunc = null;
    this.currentDepthMask = null;
    this.currentStencilFunc = null;
    this.currentStencilRef = null;
    this.currentStencilFuncMask = null;
    this.currentStencilFail = null;
    this.currentStencilZFail = null;
    this.currentStencilZPass = null;
    this.currentStencilMask = null;
    if (initialized === false) {
      this._init(this.gl);
      initialized = true;
    }
  }
  _init(gl) {
    equationToGL = {
      [AddEquation]: gl.FUNC_ADD,
      [SubtractEquation]: gl.FUNC_SUBTRACT,
      [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
    };
    factorToGL = {
      [ZeroFactor]: gl.ZERO,
      [OneFactor]: gl.ONE,
      [SrcColorFactor]: gl.SRC_COLOR,
      [SrcAlphaFactor]: gl.SRC_ALPHA,
      [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
      [DstColorFactor]: gl.DST_COLOR,
      [DstAlphaFactor]: gl.DST_ALPHA,
      [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
      [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
      [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
      [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
    };
  }
  enable(id5) {
    const { enabled } = this;
    if (enabled[id5] !== true) {
      this.gl.enable(id5);
      enabled[id5] = true;
    }
  }
  disable(id5) {
    const { enabled } = this;
    if (enabled[id5] !== false) {
      this.gl.disable(id5);
      enabled[id5] = false;
    }
  }
  setFlipSided(flipSided) {
    if (this.currentFlipSided !== flipSided) {
      const { gl } = this;
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      this.currentFlipSided = flipSided;
    }
  }
  setCullFace(cullFace) {
    const { gl } = this;
    if (cullFace !== CullFaceNone) {
      this.enable(gl.CULL_FACE);
      if (cullFace !== this.currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      this.disable(gl.CULL_FACE);
    }
    this.currentCullFace = cullFace;
  }
  setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    const { gl } = this;
    if (blending === NoBlending) {
      if (this.currentBlendingEnabled === true) {
        this.disable(gl.BLEND);
        this.currentBlendingEnabled = false;
      }
      return;
    }
    if (this.currentBlendingEnabled === false) {
      this.enable(gl.BLEND);
      this.currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
        if (this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          this.currentBlendEquation = AddEquation;
          this.currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        this.currentBlendSrc = null;
        this.currentBlendDst = null;
        this.currentBlendSrcAlpha = null;
        this.currentBlendDstAlpha = null;
        this.currentBlending = blending;
        this.currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      this.currentBlendEquation = blendEquation;
      this.currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      this.currentBlendSrc = blendSrc;
      this.currentBlendDst = blendDst;
      this.currentBlendSrcAlpha = blendSrcAlpha;
      this.currentBlendDstAlpha = blendDstAlpha;
    }
    this.currentBlending = blending;
    this.currentPremultipledAlpha = false;
  }
  setColorMask(colorMask) {
    if (this.currentColorMask !== colorMask) {
      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
      this.currentColorMask = colorMask;
    }
  }
  setDepthTest(depthTest) {
    const { gl } = this;
    if (depthTest) {
      this.enable(gl.DEPTH_TEST);
    } else {
      this.disable(gl.DEPTH_TEST);
    }
  }
  setDepthMask(depthMask) {
    if (this.currentDepthMask !== depthMask) {
      this.gl.depthMask(depthMask);
      this.currentDepthMask = depthMask;
    }
  }
  setDepthFunc(depthFunc) {
    if (this.currentDepthFunc !== depthFunc) {
      const { gl } = this;
      switch (depthFunc) {
        case NeverDepth:
          gl.depthFunc(gl.NEVER);
          break;
        case AlwaysDepth:
          gl.depthFunc(gl.ALWAYS);
          break;
        case LessDepth:
          gl.depthFunc(gl.LESS);
          break;
        case LessEqualDepth:
          gl.depthFunc(gl.LEQUAL);
          break;
        case EqualDepth:
          gl.depthFunc(gl.EQUAL);
          break;
        case GreaterEqualDepth:
          gl.depthFunc(gl.GEQUAL);
          break;
        case GreaterDepth:
          gl.depthFunc(gl.GREATER);
          break;
        case NotEqualDepth:
          gl.depthFunc(gl.NOTEQUAL);
          break;
        default:
          gl.depthFunc(gl.LEQUAL);
      }
      this.currentDepthFunc = depthFunc;
    }
  }
  setStencilTest(stencilTest) {
    const { gl } = this;
    if (stencilTest) {
      this.enable(gl.STENCIL_TEST);
    } else {
      this.disable(gl.STENCIL_TEST);
    }
  }
  setStencilMask(stencilMask) {
    if (this.currentStencilMask !== stencilMask) {
      this.gl.stencilMask(stencilMask);
      this.currentStencilMask = stencilMask;
    }
  }
  setStencilFunc(stencilFunc, stencilRef, stencilMask) {
    if (this.currentStencilFunc !== stencilFunc || this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== stencilMask) {
      this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
      this.currentStencilFunc = stencilFunc;
      this.currentStencilRef = stencilRef;
      this.currentStencilFuncMask = stencilMask;
    }
  }
  setStencilOp(stencilFail, stencilZFail, stencilZPass) {
    if (this.currentStencilFail !== stencilFail || this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== stencilZPass) {
      this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
      this.currentStencilFail = stencilFail;
      this.currentStencilZFail = stencilZFail;
      this.currentStencilZPass = stencilZPass;
    }
  }
  setMaterial(material, frontFaceCW) {
    const { gl } = this;
    material.side === DoubleSide ? this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    this.setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? this.setBlending(NoBlending) : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    this.setDepthFunc(material.depthFunc);
    this.setDepthTest(material.depthTest);
    this.setDepthMask(material.depthWrite);
    this.setColorMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    this.setStencilTest(stencilWrite);
    if (stencilWrite) {
      this.setStencilMask(material.stencilWriteMask);
      this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  setPolygonOffset(polygonOffset, factor, units) {
    const { gl } = this;
    if (polygonOffset) {
      this.enable(gl.POLYGON_OFFSET_FILL);
      if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        this.currentPolygonOffsetFactor = factor;
        this.currentPolygonOffsetUnits = units;
      }
    } else {
      this.disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  useProgram(program) {
    if (this.currentProgram !== program) {
      this.gl.useProgram(program);
      this.currentProgram = program;
      return true;
    }
    return false;
  }
};
var WebGLState_default = WebGLState;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLUtils.js
var WebGLUtils = class {
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.extensions = backend.extensions;
  }
  convert(p, colorSpace = NoColorSpace) {
    const { gl, extensions } = this;
    let extension;
    if (p === UnsignedByteType)
      return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type)
      return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type)
      return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === ByteType)
      return gl.BYTE;
    if (p === ShortType)
      return gl.SHORT;
    if (p === UnsignedShortType)
      return gl.UNSIGNED_SHORT;
    if (p === IntType)
      return gl.INT;
    if (p === UnsignedIntType)
      return gl.UNSIGNED_INT;
    if (p === FloatType)
      return gl.FLOAT;
    if (p === HalfFloatType) {
      return gl.HALF_FLOAT;
    }
    if (p === AlphaFormat)
      return gl.ALPHA;
    if (p === RGBAFormat)
      return gl.RGBA;
    if (p === LuminanceFormat)
      return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat)
      return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat)
      return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat)
      return gl.DEPTH_STENCIL;
    if (p === RedFormat)
      return gl.RED;
    if (p === RedIntegerFormat)
      return gl.RED_INTEGER;
    if (p === RGFormat)
      return gl.RG;
    if (p === RGIntegerFormat)
      return gl.RG_INTEGER;
    if (p === RGBAIntegerFormat)
      return gl.RGBA_INTEGER;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (colorSpace === SRGBColorSpace) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format)
          return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format)
          return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p === SIGNED_RED_RGTC1_Format)
          return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p === RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p === SIGNED_RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      return gl.UNSIGNED_INT_24_8;
    }
    return gl[p] !== void 0 ? gl[p] : null;
  }
  _clientWaitAsync() {
    const { gl } = this;
    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    gl.flush();
    return new Promise((resolve, reject) => {
      function test() {
        const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (res === gl.WAIT_FAILED) {
          gl.deleteSync(sync);
          reject();
          return;
        }
        if (res === gl.TIMEOUT_EXPIRED) {
          requestAnimationFrame(test);
          return;
        }
        gl.deleteSync(sync);
        resolve();
      }
      test();
    });
  }
};
var WebGLUtils_default = WebGLUtils;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLTextureUtils.js
var initialized2 = false;
var wrappingToGL;
var filterToGL;
var compareToGL;
var WebGLTextureUtils = class {
  constructor(backend) {
    this.backend = backend;
    this.gl = backend.gl;
    this.extensions = backend.extensions;
    if (initialized2 === false) {
      this._init(this.gl);
      initialized2 = true;
    }
  }
  _init(gl) {
    wrappingToGL = {
      [RepeatWrapping]: gl.REPEAT,
      [ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: gl.MIRRORED_REPEAT
    };
    filterToGL = {
      [NearestFilter]: gl.NEAREST,
      [NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: gl.LINEAR,
      [LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR
    };
    compareToGL = {
      [NeverCompare]: gl.NEVER,
      [AlwaysCompare]: gl.ALWAYS,
      [LessCompare]: gl.LESS,
      [LessEqualCompare]: gl.LEQUAL,
      [EqualCompare]: gl.EQUAL,
      [GreaterEqualCompare]: gl.GEQUAL,
      [GreaterCompare]: gl.GREATER,
      [NotEqualCompare]: gl.NOTEQUAL
    };
  }
  filterFallback(f) {
    const { gl } = this;
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return gl.NEAREST;
    }
    return gl.LINEAR;
  }
  getGLTextureType(texture2) {
    const { gl } = this;
    let glTextureType;
    if (texture2.isCubeTexture === true) {
      glTextureType = gl.TEXTURE_CUBE_MAP;
    } else if (texture2.isDataArrayTexture === true) {
      glTextureType = gl.TEXTURE_2D_ARRAY;
    } else {
      glTextureType = gl.TEXTURE_2D;
    }
    return glTextureType;
  }
  getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    const { gl, extensions } = this;
    if (internalFormatName !== null) {
      if (gl[internalFormatName] !== void 0)
        return gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === gl.RED) {
      if (glType === gl.FLOAT)
        internalFormat = gl.R32F;
      if (glType === gl.HALF_FLOAT)
        internalFormat = gl.R16F;
      if (glType === gl.UNSIGNED_BYTE)
        internalFormat = gl.R8;
    }
    if (glFormat === gl.RED_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE)
        internalFormat = gl.R8UI;
      if (glType === gl.UNSIGNED_SHORT)
        internalFormat = gl.R16UI;
      if (glType === gl.UNSIGNED_INT)
        internalFormat = gl.R32UI;
      if (glType === gl.BYTE)
        internalFormat = gl.R8I;
      if (glType === gl.SHORT)
        internalFormat = gl.R16I;
      if (glType === gl.INT)
        internalFormat = gl.R32I;
    }
    if (glFormat === gl.RG) {
      if (glType === gl.FLOAT)
        internalFormat = gl.RG32F;
      if (glType === gl.HALF_FLOAT)
        internalFormat = gl.RG16F;
      if (glType === gl.UNSIGNED_BYTE)
        internalFormat = gl.RG8;
    }
    if (glFormat === gl.RGBA) {
      if (glType === gl.FLOAT)
        internalFormat = gl.RGBA32F;
      if (glType === gl.HALF_FLOAT)
        internalFormat = gl.RGBA16F;
      if (glType === gl.UNSIGNED_BYTE)
        internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8_ALPHA8 : gl.RGBA8;
      if (glType === gl.UNSIGNED_SHORT_4_4_4_4)
        internalFormat = gl.RGBA4;
      if (glType === gl.UNSIGNED_SHORT_5_5_5_1)
        internalFormat = gl.RGB5_A1;
    }
    if (glFormat === gl.DEPTH_COMPONENT) {
      if (glType === gl.UNSIGNED_INT)
        internalFormat = gl.DEPTH24_STENCIL8;
      if (glType === gl.FLOAT)
        internalFormat = gl.DEPTH_COMPONENT32F;
    }
    if (glFormat === gl.DEPTH_STENCIL) {
      if (glType === gl.UNSIGNED_INT_24_8)
        internalFormat = gl.DEPTH24_STENCIL8;
    }
    if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  setTextureParameters(textureType, texture2) {
    const { gl, extensions } = this;
    gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture2.wrapS]);
    gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture2.wrapT]);
    if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {
      gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture2.wrapR]);
    }
    gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture2.magFilter]);
    gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[texture2.minFilter]);
    if (texture2.compareFunction) {
      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture2.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture2.magFilter === NearestFilter)
        return;
      if (texture2.minFilter !== NearestMipmapLinearFilter && texture2.minFilter !== LinearMipmapLinearFilter)
        return;
      if (texture2.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (texture2.anisotropy > 1) {
      }
    }
  }
  async copyTextureToBuffer(texture2, x, y, width, height) {
    const { backend, gl } = this;
    const { textureGPU, glFormat, glType } = this.backend.get(texture2);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureGPU, 0);
    const typedArrayType = this._getTypedArrayType(glType);
    const bytesPerTexel = this._getBytesPerTexel(glFormat);
    const elementCount = width * height;
    const byteLength = elementCount * bytesPerTexel;
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);
    gl.readPixels(x, y, width, height, glFormat, glType, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    await backend.utils._clientWaitAsync();
    const dstBuffer = new typedArrayType(elementCount);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);
    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    gl.deleteFramebuffer(fb);
    return dstBuffer;
  }
  _getTypedArrayType(glType) {
    const { gl } = this;
    if (glType === gl.UNSIGNED_BYTE)
      return Uint8Array;
    if (glType === gl.UNSIGNED_SHORT_4_4_4_4)
      return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_5_5_1)
      return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_6_5)
      return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT)
      return Uint16Array;
    if (glType === gl.UNSIGNED_INT)
      return Uint32Array;
    if (glType === gl.UNSIGNED_FLOAT)
      return Float32Array;
  }
  _getBytesPerTexel(glFormat) {
    const { gl } = this;
    if (glFormat === gl.RGBA)
      return 4;
    if (glFormat === gl.RGB)
      return 3;
    if (glFormat === gl.ALPHA)
      return 1;
  }
};
var WebGLTextureUtils_default = WebGLTextureUtils;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLExtensions.js
var WebGLExtensions = class {
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.availableExtensions = this.gl.getSupportedExtensions();
    this.extensions = {};
  }
  get(name) {
    let extension = this.extensions[name];
    if (extension === void 0) {
      extension = this.gl.getExtension(name);
    }
    return extension;
  }
  has(name) {
    return this.availableExtensions.includes(name);
  }
};
var WebGLExtensions_default = WebGLExtensions;

// node_modules/three/examples/jsm/renderers/webgl/utils/WebGLCapabilities.js
var WebGLCapabilities = class {
  constructor(backend) {
    this.backend = backend;
    this.maxAnisotropy = null;
  }
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null)
      return this.maxAnisotropy;
    const gl = this.backend.gl;
    const extensions = this.backend.extensions;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      this.maxAnisotropy = 0;
    }
    return this.maxAnisotropy;
  }
};
var WebGLCapabilities_default = WebGLCapabilities;

// node_modules/three/examples/jsm/renderers/webgl/WebGLBackend.js
var WebGLBackend = class extends Backend_default {
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGLBackend = true;
  }
  async init(renderer) {
    await super.init(renderer);
    const parameters = this.parameters;
    const glContext = parameters.context !== void 0 ? parameters.context : renderer.domElement.getContext("webgl2");
    this.gl = glContext;
    this.extensions = new WebGLExtensions_default(this);
    this.capabilities = new WebGLCapabilities_default(this);
    this.attributeUtils = new WebGLAttributeUtils_default(this);
    this.textureUtils = new WebGLTextureUtils_default(this);
    this.state = new WebGLState_default(this);
    this.utils = new WebGLUtils_default(this);
    this.defaultTextures = {};
    this.extensions.get("EXT_color_buffer_float");
    this._currentContext = null;
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  async getArrayBufferAsync(attribute) {
    return await this.attributeUtils.getArrayBufferAsync(attribute);
  }
  beginRender(renderContext) {
    const { gl } = this;
    const renderContextData = this.get(renderContext);
    renderContextData.previousContext = this._currentContext;
    this._currentContext = renderContext;
    this._setFramebuffer(renderContext);
    this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext);
    if (renderContext.viewport) {
      this.updateViewport(renderContext);
    } else {
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
      renderContextData.lastOcclusionObject = null;
      renderContextData.occlusionQueries = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryIndex = 0;
    }
  }
  finishRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const previousContext = renderContextData.previousContext;
    this._currentContext = previousContext;
    if (previousContext !== null) {
      this._setFramebuffer(previousContext);
      if (previousContext.viewport) {
        this.updateViewport(previousContext);
      } else {
        const gl = this.gl;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      }
    }
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      const renderContextData2 = this.get(renderContext);
      if (occlusionQueryCount > renderContextData2.occlusionQueryIndex) {
        const { gl } = this;
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
      }
      this.resolveOccludedAsync(renderContext);
    }
  }
  resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;
    if (currentOcclusionQueries && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      const { gl } = this;
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueries = null;
      const check = () => {
        let completed = 0;
        for (let i = 0; i < currentOcclusionQueries.length; i++) {
          const query = currentOcclusionQueries[i];
          if (query === null)
            continue;
          if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {
            if (gl.getQueryParameter(query, gl.QUERY_RESULT) > 0)
              occluded.add(currentOcclusionQueryObjects[i]);
            currentOcclusionQueries[i] = null;
            gl.deleteQuery(query);
            completed++;
          }
        }
        if (completed < currentOcclusionQueries.length) {
          requestAnimationFrame(check);
        } else {
          renderContextData.occluded = occluded;
        }
      };
      check();
    }
  }
  isOccluded(renderContext, object) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object);
  }
  updateViewport(renderContext) {
    const gl = this.gl;
    const { x, y, width, height } = renderContext.viewportValue;
    gl.viewport(x, y, width, height);
  }
  clear(color, depth, stencil, descriptor = null) {
    const { gl } = this;
    if (descriptor === null) {
      descriptor = {
        textures: null,
        clearColorValue: this.getClearColor()
      };
    }
    let clear = 0;
    if (color)
      clear |= gl.COLOR_BUFFER_BIT;
    if (depth)
      clear |= gl.DEPTH_BUFFER_BIT;
    if (stencil)
      clear |= gl.STENCIL_BUFFER_BIT;
    if (clear !== 0) {
      const clearColor = descriptor.clearColorValue;
      if (depth)
        this.state.setDepthMask(true);
      if (descriptor.textures === null) {
        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
        gl.clear(clear);
      } else {
        if (color) {
          for (let i = 0; i < descriptor.textures.length; i++) {
            gl.clearBufferfv(gl.COLOR, i, [clearColor.r, clearColor.g, clearColor.b, clearColor.a]);
          }
        }
        if (depth && stencil) {
          gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);
        } else if (depth) {
          gl.clearBufferfv(gl.DEPTH, 0, [1]);
        } else if (stencil) {
          gl.clearBufferiv(gl.STENCIL, 0, [0]);
        }
      }
    }
  }
  beginCompute() {
    console.warn("Abstract class.");
  }
  compute() {
    console.warn("Abstract class.");
  }
  finishCompute() {
    console.warn("Abstract class.");
  }
  draw(renderObject, info) {
    const { pipeline, material, context: context2 } = renderObject;
    const { programGPU, vaoGPU } = this.get(pipeline);
    const { gl, state } = this;
    const contextData = this.get(context2);
    const bindings = renderObject.getBindings();
    for (const binding of bindings) {
      const bindingData = this.get(binding);
      const index2 = bindingData.index;
      if (binding.isUniformsGroup || binding.isUniformBuffer) {
        gl.bindBufferBase(gl.UNIFORM_BUFFER, index2, bindingData.bufferGPU);
      } else if (binding.isSampledTexture) {
        gl.activeTexture(gl.TEXTURE0 + index2);
        gl.bindTexture(bindingData.glTextureType, bindingData.textureGPU);
      }
    }
    state.setMaterial(material);
    gl.useProgram(programGPU);
    gl.bindVertexArray(vaoGPU);
    const index = renderObject.getIndex();
    const object = renderObject.object;
    const geometry = renderObject.geometry;
    const drawRange = geometry.drawRange;
    const firstVertex = drawRange.start;
    const lastObject = contextData.lastOcclusionObject;
    if (lastObject !== object && lastObject !== void 0) {
      if (lastObject !== null && lastObject.occlusionTest === true) {
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
        contextData.occlusionQueryIndex++;
      }
      if (object.occlusionTest === true) {
        const query = gl.createQuery();
        gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
        contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;
        contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;
      }
      contextData.lastOcclusionObject = object;
    }
    let mode;
    if (object.isPoints)
      mode = gl.POINTS;
    else if (object.isLineSegments)
      mode = gl.LINES;
    else if (object.isLine)
      mode = gl.LINE_STRIP;
    else if (object.isLineLoop)
      mode = gl.LINE_LOOP;
    else
      mode = gl.TRIANGLES;
    const instanceCount = this.getInstanceCount(renderObject);
    if (index !== null) {
      const indexData = this.get(index);
      const indexCount = drawRange.count !== Infinity ? drawRange.count : index.count;
      if (instanceCount > 1) {
        gl.drawElementsInstanced(mode, index.count, indexData.type, firstVertex, instanceCount);
      } else {
        gl.drawElements(mode, index.count, indexData.type, firstVertex);
      }
      info.update(object, indexCount, 1);
    } else {
      const positionAttribute = geometry.attributes.position;
      const vertexCount = drawRange.count !== Infinity ? drawRange.count : positionAttribute.count;
      if (instanceCount > 1) {
        gl.drawArraysInstanced(mode, 0, vertexCount, instanceCount);
      } else {
        gl.drawArrays(mode, 0, vertexCount);
      }
      info.update(object, vertexCount, 1);
    }
    gl.bindVertexArray(null);
  }
  needsRenderUpdate(renderObject) {
    return false;
  }
  getRenderCacheKey(renderObject) {
    return renderObject.id;
  }
  // textures
  createSampler() {
  }
  createDefaultTexture(texture2) {
    const { gl, textureUtils, defaultTextures } = this;
    const glTextureType = textureUtils.getGLTextureType(texture2);
    let textureGPU = defaultTextures[glTextureType];
    if (textureGPU === void 0) {
      textureGPU = gl.createTexture();
      gl.bindTexture(glTextureType, textureGPU);
      gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      defaultTextures[glTextureType] = textureGPU;
    }
    this.set(texture2, {
      textureGPU,
      glTextureType,
      isDefault: true
    });
  }
  createTexture(texture2, options) {
    const { gl, utils, textureUtils } = this;
    const { levels, width, height, depth } = options;
    const glFormat = utils.convert(texture2.format, texture2.colorSpace);
    const glType = utils.convert(texture2.type);
    const glInternalFormat = textureUtils.getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, texture2.isVideoTexture);
    const textureGPU = gl.createTexture();
    const glTextureType = textureUtils.getGLTextureType(texture2);
    gl.bindTexture(glTextureType, textureGPU);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture2.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture2.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture2.unpackAlignment);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    textureUtils.setTextureParameters(glTextureType, texture2);
    gl.bindTexture(glTextureType, textureGPU);
    if (texture2.isDataArrayTexture) {
      gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth);
    } else if (!texture2.isVideoTexture) {
      gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);
    }
    this.set(texture2, {
      textureGPU,
      glTextureType,
      glFormat,
      glType,
      glInternalFormat
    });
  }
  updateTexture(texture2, options) {
    const { gl } = this;
    const { width, height } = options;
    const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.get(texture2);
    const getImage = (source) => {
      if (source.isDataTexture) {
        return source.image.data;
      } else if (source instanceof ImageBitmap || source instanceof OffscreenCanvas || source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {
        return source;
      }
      return source.data;
    };
    gl.bindTexture(glTextureType, textureGPU);
    if (texture2.isCubeTexture) {
      const images = options.images;
      for (let i = 0; i < 6; i++) {
        const image = getImage(images[i]);
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image);
      }
    } else if (texture2.isDataArrayTexture) {
      const image = options.image;
      gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
    } else if (texture2.isVideoTexture) {
      texture2.update();
      gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);
    } else {
      const image = getImage(options.image);
      gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, image);
    }
  }
  generateMipmaps(texture2) {
    const { gl } = this;
    const { textureGPU, glTextureType } = this.get(texture2);
    gl.bindTexture(glTextureType, textureGPU);
    gl.generateMipmap(glTextureType);
  }
  destroyTexture(texture2) {
    const { gl } = this;
    const { textureGPU } = this.get(texture2);
    gl.deleteTexture(textureGPU);
    this.delete(texture2);
  }
  destroySampler() {
  }
  copyTextureToBuffer(texture2, x, y, width, height) {
    return this.textureUtils.copyTextureToBuffer(texture2, x, y, width, height);
  }
  // node builder
  createNodeBuilder(object, renderer, scene = null) {
    return new GLSLNodeBuilder_default(object, renderer, scene);
  }
  // program
  createProgram(program) {
    const gl = this.gl;
    const { stage, code } = program;
    const shader = stage === "vertex" ? gl.createShader(gl.VERTEX_SHADER) : gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(shader, code);
    gl.compileShader(shader);
    this.set(program, {
      shaderGPU: shader
    });
  }
  destroyProgram() {
    console.warn("Abstract class.");
  }
  createRenderPipeline(renderObject) {
    const gl = this.gl;
    const pipeline = renderObject.pipeline;
    const { fragmentProgram, vertexProgram } = pipeline;
    const programGPU = gl.createProgram();
    const fragmentShader = this.get(fragmentProgram).shaderGPU;
    const vertexShader = this.get(vertexProgram).shaderGPU;
    gl.attachShader(programGPU, fragmentShader);
    gl.attachShader(programGPU, vertexShader);
    gl.linkProgram(programGPU);
    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
      console.error("THREE.WebGLBackend:", gl.getProgramInfoLog(programGPU));
      console.error("THREE.WebGLBackend:", gl.getShaderInfoLog(fragmentShader));
      console.error("THREE.WebGLBackend:", gl.getShaderInfoLog(vertexShader));
    }
    gl.useProgram(programGPU);
    const bindings = renderObject.getBindings();
    for (const binding of bindings) {
      const bindingData = this.get(binding);
      const index2 = bindingData.index;
      if (binding.isUniformsGroup || binding.isUniformBuffer) {
        const location = gl.getUniformBlockIndex(programGPU, binding.name);
        gl.uniformBlockBinding(programGPU, location, index2);
      } else if (binding.isSampledTexture) {
        const location = gl.getUniformLocation(programGPU, binding.name);
        gl.uniform1i(location, index2);
      }
    }
    const vaoGPU = gl.createVertexArray();
    const index = renderObject.getIndex();
    const attributes = renderObject.getAttributes();
    gl.bindVertexArray(vaoGPU);
    if (index !== null) {
      const indexData = this.get(index);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU);
    }
    for (let i = 0; i < attributes.length; i++) {
      const attribute = attributes[i];
      const attributeData = this.get(attribute);
      gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);
      gl.enableVertexAttribArray(i);
      let stride, offset;
      if (attribute.isInterleavedBufferAttribute === true) {
        stride = attribute.data.stride * attributeData.bytesPerElement;
        offset = attribute.offset * attributeData.bytesPerElement;
      } else {
        stride = 0;
        offset = 0;
      }
      if (attributeData.isInteger) {
        gl.vertexAttribIPointer(i, attribute.itemSize, attributeData.type, stride, offset);
      } else {
        gl.vertexAttribPointer(i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset);
      }
      if (attribute.isInstancedBufferAttribute && !attribute.isInterleavedBufferAttribute) {
        gl.vertexAttribDivisor(i, attribute.meshPerAttribute);
      } else if (attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer) {
        gl.vertexAttribDivisor(i, attribute.data.meshPerAttribute);
      }
    }
    gl.bindVertexArray(null);
    this.set(pipeline, {
      programGPU,
      vaoGPU
    });
  }
  createComputePipeline() {
    console.warn("Abstract class.");
  }
  createBindings(bindings) {
    this.updateBindings(bindings);
  }
  updateBindings(bindings) {
    const { gl } = this;
    let groupIndex = 0;
    let textureIndex = 0;
    for (const binding of bindings) {
      if (binding.isUniformsGroup || binding.isUniformBuffer) {
        const bufferGPU = gl.createBuffer();
        const data = binding.buffer;
        gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
        gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
        gl.bindBufferBase(gl.UNIFORM_BUFFER, groupIndex, bufferGPU);
        this.set(binding, {
          index: groupIndex++,
          bufferGPU
        });
      } else if (binding.isSampledTexture) {
        const { textureGPU, glTextureType } = this.get(binding.texture);
        this.set(binding, {
          index: textureIndex++,
          textureGPU,
          glTextureType
        });
      }
    }
  }
  updateBinding(binding) {
    const gl = this.gl;
    if (binding.isUniformsGroup || binding.isUniformBuffer) {
      const bindingData = this.get(binding);
      const bufferGPU = bindingData.bufferGPU;
      const data = binding.buffer;
      gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
      gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
    }
  }
  // attributes
  createIndexAttribute(attribute) {
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
  }
  createAttribute(attribute) {
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);
  }
  createStorageAttribute() {
    console.warn("Abstract class.");
  }
  updateAttribute(attribute) {
    this.attributeUtils.updateAttribute(attribute);
  }
  destroyAttribute() {
    console.warn("Abstract class.");
  }
  updateSize() {
  }
  hasFeature() {
    return true;
  }
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  copyFramebufferToTexture(texture2, renderContext) {
    const { gl } = this;
    const { textureGPU } = this.get(texture2);
    const width = texture2.image.width;
    const height = texture2.image.height;
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    if (texture2.isDepthTexture) {
      const fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, textureGPU, 0);
      gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.DEPTH_BUFFER_BIT, gl.NEAREST);
      gl.deleteFramebuffer(fb);
    } else {
      gl.bindTexture(gl.TEXTURE_2D, textureGPU);
      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, width, height);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    if (texture2.generateMipmaps)
      this.generateMipmaps(texture2);
    this._setFramebuffer(renderContext);
  }
  _setFramebuffer(renderContext) {
    const { gl } = this;
    if (renderContext.textures !== null) {
      const renderContextData = this.get(renderContext.renderTarget);
      let fb = renderContextData.framebuffer;
      if (fb === void 0) {
        fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        const textures = renderContext.textures;
        const drawBuffers = [];
        for (let i = 0; i < textures.length; i++) {
          const texture2 = textures[i];
          const { textureGPU } = this.get(texture2);
          const attachment = gl.COLOR_ATTACHMENT0 + i;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, textureGPU, 0);
          drawBuffers.push(attachment);
        }
        gl.drawBuffers(drawBuffers);
        if (renderContext.depthTexture !== null) {
          const { textureGPU } = this.get(renderContext.depthTexture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, textureGPU, 0);
        }
        renderContextData.framebuffer = fb;
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      }
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
  }
};
var WebGLBackend_default = WebGLBackend;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUConstants.js
var GPUPrimitiveTopology = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
};
var GPUCompareFunction = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
};
var GPUStoreOp = {
  Store: "store",
  Discard: "discard"
};
var GPULoadOp = {
  Load: "load",
  Clear: "clear"
};
var GPUFrontFace = {
  CCW: "ccw",
  CW: "cw"
};
var GPUCullMode = {
  None: "none",
  Front: "front",
  Back: "back"
};
var GPUIndexFormat = {
  Uint16: "uint16",
  Uint32: "uint32"
};
var GPUTextureFormat = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  RG11B10uFloat: "rgb10a2unorm",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  // Depth and stencil formats
  Stencil8: "stencil8",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC4RSnorm: "bc4-r-snorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
};
var GPUAddressMode = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
};
var GPUFilterMode = {
  Linear: "linear",
  Nearest: "nearest"
};
var GPUBlendFactor = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDstColor: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
};
var GPUBlendOperation = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
};
var GPUColorWriteFlags = {
  None: 0,
  Red: 1,
  Green: 2,
  Blue: 4,
  Alpha: 8,
  All: 15
};
var GPUStencilOperation = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
};
var GPUBufferBindingType = {
  Uniform: "uniform",
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
};
var GPUTextureSampleType = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
};
var GPUTextureDimension = {
  OneD: "1d",
  TwoD: "2d",
  ThreeD: "3d"
};
var GPUTextureViewDimension = {
  OneD: "1d",
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  CubeArray: "cube-array",
  ThreeD: "3d"
};
var GPUTextureAspect = {
  All: "all",
  StencilOnly: "stencil-only",
  DepthOnly: "depth-only"
};
var GPUInputStepMode = {
  Vertex: "vertex",
  Instance: "instance"
};
var GPUFeatureName = {
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable"
};

// node_modules/three/examples/jsm/renderers/common/Sampler.js
var Sampler = class extends Binding_default {
  constructor(name, texture2) {
    super(name);
    this.texture = texture2;
    this.version = texture2 ? texture2.version : 0;
    this.isSampler = true;
  }
};
var Sampler_default = Sampler;

// node_modules/three/examples/jsm/renderers/common/nodes/NodeSampler.js
var NodeSampler = class extends Sampler_default {
  constructor(name, textureNode) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
  }
};
var NodeSampler_default = NodeSampler;

// node_modules/three/examples/jsm/renderers/common/StorageBuffer.js
var StorageBuffer = class extends Buffer_default {
  constructor(name, attribute) {
    super(name, attribute ? attribute.array : null);
    this.attribute = attribute;
    this.isStorageBuffer = true;
  }
};
var StorageBuffer_default = StorageBuffer;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUTexturePassUtils.js
var WebGPUTexturePassUtils = class {
  constructor(device) {
    this.device = device;
    const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;
    const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;
    const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = device.createSampler({ minFilter: GPUFilterMode.Linear });
    this.flipYSampler = device.createSampler({ minFilter: GPUFilterMode.Nearest });
    this.transferPipelines = {};
    this.flipYPipelines = {};
    this.mipmapVertexShaderModule = device.createShaderModule({
      label: "mipmapVertex",
      code: mipmapVertexSource
    });
    this.mipmapFragmentShaderModule = device.createShaderModule({
      label: "mipmapFragment",
      code: mipmapFragmentSource
    });
    this.flipYFragmentShaderModule = device.createShaderModule({
      label: "flipYFragment",
      code: flipYFragmentSource
    });
  }
  getTransferPipeline(format) {
    let pipeline = this.transferPipelines[format];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main"
        },
        fragment: {
          module: this.mipmapFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format }]
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32
        },
        layout: "auto"
      });
      this.transferPipelines[format] = pipeline;
    }
    return pipeline;
  }
  getFlipYPipeline(format) {
    let pipeline = this.flipYPipelines[format];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main"
        },
        fragment: {
          module: this.flipYFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format }]
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32
        },
        layout: "auto"
      });
      this.flipYPipelines[format] = pipeline;
    }
    return pipeline;
  }
  flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const format = textureGPUDescriptor.format;
    const { width, height } = textureGPUDescriptor.size;
    const transferPipeline = this.getTransferPipeline(format);
    const flipYPipeline = this.getFlipYPipeline(format);
    const tempTexture = this.device.createTexture({
      size: { width, height, depthOrArrayLayers: 1 },
      format,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    const srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer
    });
    const dstView = tempTexture.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer: 0
    });
    const commandEncoder = this.device.createCommandEncoder({});
    const pass = (pipeline, sourceView, destinationView) => {
      const bindGroupLayout = pipeline.getBindGroupLayout(0);
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: sourceView
        }]
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: destinationView,
          loadOp: GPULoadOp.Clear,
          storeOp: GPUStoreOp.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
    };
    pass(transferPipeline, srcView, dstView);
    pass(flipYPipeline, dstView, srcView);
    this.device.queue.submit([commandEncoder.finish()]);
    tempTexture.destroy();
  }
  generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);
    const commandEncoder = this.device.createCommandEncoder({});
    const bindGroupLayout = pipeline.getBindGroupLayout(0);
    let srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer
    });
    for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: srcView
        }]
      });
      const dstView = textureGPU.createView({
        baseMipLevel: i,
        mipLevelCount: 1,
        dimension: GPUTextureViewDimension.TwoD,
        baseArrayLayer
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: dstView,
          loadOp: GPULoadOp.Clear,
          storeOp: GPUStoreOp.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
      srcView = dstView;
    }
    this.device.queue.submit([commandEncoder.finish()]);
  }
};
var WebGPUTexturePassUtils_default = WebGPUTexturePassUtils;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUTextureUtils.js
var _compareToWebGPU = {
  [NeverCompare]: "never",
  [LessCompare]: "less",
  [EqualCompare]: "equal",
  [LessEqualCompare]: "less-equal",
  [GreaterCompare]: "greater",
  [GreaterEqualCompare]: "greater-equal",
  [AlwaysCompare]: "always",
  [NotEqualCompare]: "not-equal"
};
var _flipMap = [0, 1, 3, 2, 4, 5];
var WebGPUTextureUtils = class {
  constructor(backend) {
    this.backend = backend;
    this._passUtils = null;
    this.defaultTexture = null;
    this.defaultCubeTexture = null;
    this.colorBuffer = null;
    this.depthTexture = new DepthTexture();
    this.depthTexture.name = "depthBuffer";
  }
  createSampler(texture2) {
    const backend = this.backend;
    const device = backend.device;
    const textureGPU = backend.get(texture2);
    const samplerDescriptorGPU = {
      addressModeU: this._convertAddressMode(texture2.wrapS),
      addressModeV: this._convertAddressMode(texture2.wrapT),
      addressModeW: this._convertAddressMode(texture2.wrapR),
      magFilter: this._convertFilterMode(texture2.magFilter),
      minFilter: this._convertFilterMode(texture2.minFilter),
      mipmapFilter: this._convertFilterMode(texture2.minFilter),
      maxAnisotropy: texture2.anisotropy
    };
    if (texture2.isDepthTexture && texture2.compareFunction !== null) {
      samplerDescriptorGPU.compare = _compareToWebGPU[texture2.compareFunction];
    }
    textureGPU.sampler = device.createSampler(samplerDescriptorGPU);
  }
  createDefaultTexture(texture2) {
    let textureGPU;
    if (texture2.isCubeTexture) {
      textureGPU = this._getDefaultCubeTextureGPU();
    } else {
      textureGPU = this._getDefaultTextureGPU();
    }
    this.backend.get(texture2).texture = textureGPU;
  }
  createTexture(texture2, options = {}) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    if (textureData.initialized) {
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    }
    if (options.needsMipmaps === void 0)
      options.needsMipmaps = false;
    if (options.levels === void 0)
      options.levels = 1;
    if (options.depth === void 0)
      options.depth = 1;
    const { width, height, depth, levels } = options;
    const dimension = this._getDimension(texture2);
    const format = texture2.internalFormat || getFormat(texture2, backend.device);
    const sampleCount = options.sampleCount !== void 0 ? options.sampleCount : 1;
    const primarySampleCount = texture2.isRenderTargetTexture ? 1 : sampleCount;
    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    if (texture2.isStorageTexture === true) {
      usage |= GPUTextureUsage.STORAGE_BINDING;
    }
    if (texture2.isCompressedTexture !== true) {
      usage |= GPUTextureUsage.RENDER_ATTACHMENT;
    }
    const textureDescriptorGPU = {
      label: texture2.name,
      size: {
        width,
        height,
        depthOrArrayLayers: depth
      },
      mipLevelCount: levels,
      sampleCount: primarySampleCount,
      dimension,
      format,
      usage
    };
    if (texture2.isVideoTexture) {
      const video = texture2.source.data;
      const videoFrame = new VideoFrame(video);
      textureDescriptorGPU.size.width = videoFrame.displayWidth;
      textureDescriptorGPU.size.height = videoFrame.displayHeight;
      videoFrame.close();
      textureData.externalTexture = video;
    } else {
      if (format === void 0) {
        console.warn("WebGPURenderer: Texture format not supported.");
        return this.createDefaultTexture(texture2);
      }
      textureData.texture = backend.device.createTexture(textureDescriptorGPU);
    }
    if (texture2.isRenderTargetTexture && sampleCount > 1) {
      const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);
      msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + "-msaa";
      msaaTextureDescriptorGPU.sampleCount = sampleCount;
      textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);
    }
    textureData.initialized = true;
    textureData.textureDescriptorGPU = textureDescriptorGPU;
  }
  destroyTexture(texture2) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    textureData.texture.destroy();
    if (textureData.msaaTexture !== void 0)
      textureData.msaaTexture.destroy();
    backend.delete(texture2);
  }
  destroySampler(texture2) {
    const backend = this.backend;
    const textureData = backend.get(texture2);
    delete textureData.sampler;
  }
  generateMipmaps(texture2) {
    const textureData = this.backend.get(texture2);
    if (texture2.isCubeTexture) {
      for (let i = 0; i < 6; i++) {
        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);
      }
    } else {
      this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU);
    }
  }
  getColorBuffer() {
    if (this.colorBuffer)
      this.colorBuffer.destroy();
    const backend = this.backend;
    const { width, height } = backend.getDrawingBufferSize();
    this.colorBuffer = backend.device.createTexture({
      label: "colorBuffer",
      size: {
        width,
        height,
        depthOrArrayLayers: 1
      },
      sampleCount: backend.parameters.sampleCount,
      format: GPUTextureFormat.BGRA8Unorm,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    });
    return this.colorBuffer;
  }
  getDepthBuffer(depth = true, stencil = true) {
    const backend = this.backend;
    const { width, height } = backend.getDrawingBufferSize();
    const depthTexture = this.depthTexture;
    const depthTextureGPU = backend.get(depthTexture).texture;
    let format, type;
    if (stencil) {
      format = DepthStencilFormat;
      type = UnsignedInt248Type;
    } else if (depth) {
      format = DepthFormat;
      type = UnsignedIntType;
    }
    if (depthTextureGPU !== void 0) {
      if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type) {
        return depthTextureGPU;
      }
      this.destroyTexture(depthTexture);
    }
    depthTexture.name = "depthBuffer";
    depthTexture.format = format;
    depthTexture.type = type;
    depthTexture.image.width = width;
    depthTexture.image.height = height;
    this.createTexture(depthTexture, { sampleCount: backend.parameters.sampleCount, width, height });
    return backend.get(depthTexture).texture;
  }
  updateTexture(texture2, options) {
    const textureData = this.backend.get(texture2);
    const { textureDescriptorGPU } = textureData;
    if (texture2.isRenderTargetTexture || textureDescriptorGPU === void 0)
      return;
    if (texture2.isDataTexture || texture2.isData3DTexture) {
      this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, false);
    } else if (texture2.isDataArrayTexture) {
      for (let i = 0; i < options.image.depth; i++) {
        this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i, false, i);
      }
    } else if (texture2.isCompressedTexture) {
      this._copyCompressedBufferToTexture(texture2.mipmaps, textureData.texture, textureDescriptorGPU);
    } else if (texture2.isCubeTexture) {
      this._copyCubeMapToTexture(options.images, textureData.texture, textureDescriptorGPU, texture2.flipY);
    } else if (texture2.isVideoTexture) {
      const video = texture2.source.data;
      textureData.externalTexture = video;
    } else {
      this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture2.flipY);
    }
    textureData.version = texture2.version;
    if (texture2.onUpdate)
      texture2.onUpdate(texture2);
  }
  async copyTextureToBuffer(texture2, x, y, width, height) {
    const device = this.backend.device;
    const textureData = this.backend.get(texture2);
    const textureGPU = textureData.texture;
    const format = textureData.textureDescriptorGPU.format;
    const bytesPerTexel = this._getBytesPerTexel(format);
    const readBuffer = device.createBuffer(
      {
        size: width * height * bytesPerTexel,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    );
    const encoder = device.createCommandEncoder();
    encoder.copyTextureToBuffer(
      {
        texture: textureGPU,
        origin: { x, y }
      },
      {
        buffer: readBuffer,
        bytesPerRow: width * bytesPerTexel
      },
      {
        width,
        height
      }
    );
    const typedArrayType = this._getTypedArrayType(format);
    device.queue.submit([encoder.finish()]);
    await readBuffer.mapAsync(GPUMapMode.READ);
    const buffer = readBuffer.getMappedRange();
    return new typedArrayType(buffer);
  }
  _isEnvironmentTexture(texture2) {
    const mapping = texture2.mapping;
    return mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping || (mapping === CubeReflectionMapping || mapping === CubeRefractionMapping);
  }
  _getDefaultTextureGPU() {
    let defaultTexture = this.defaultTexture;
    if (defaultTexture === null) {
      const texture2 = new Texture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this.createTexture(texture2, { width: 1, height: 1 });
      this.defaultTexture = defaultTexture = texture2;
    }
    return this.backend.get(defaultTexture).texture;
  }
  _getDefaultCubeTextureGPU() {
    let defaultCubeTexture = this.defaultTexture;
    if (defaultCubeTexture === null) {
      const texture2 = new CubeTexture();
      texture2.minFilter = NearestFilter;
      texture2.magFilter = NearestFilter;
      this.createTexture(texture2, { width: 1, height: 1, depth: 6 });
      this.defaultCubeTexture = defaultCubeTexture = texture2;
    }
    return this.backend.get(defaultCubeTexture).texture;
  }
  _copyCubeMapToTexture(images, textureGPU, textureDescriptorGPU, flipY) {
    for (let i = 0; i < 6; i++) {
      const image = images[i];
      const flipIndex = flipY === true ? _flipMap[i] : i;
      if (image.isDataTexture) {
        this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY);
      } else {
        this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, flipY);
      }
    }
  }
  _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {
    const device = this.backend.device;
    device.queue.copyExternalImageToTexture(
      {
        source: image
      },
      {
        texture: textureGPU,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: originDepth }
      },
      {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 1
      }
    );
    if (flipY === true) {
      this._flipY(textureGPU, textureDescriptorGPU, originDepth);
    }
  }
  _getPassUtils() {
    let passUtils = this._passUtils;
    if (passUtils === null) {
      this._passUtils = passUtils = new WebGPUTexturePassUtils_default(this.backend.device);
    }
    return passUtils;
  }
  _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0) {
    this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer);
  }
  _flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {
    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);
  }
  _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0) {
    const device = this.backend.device;
    const data = image.data;
    const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);
    const bytesPerRow = image.width * bytesPerTexel;
    device.queue.writeTexture(
      {
        texture: textureGPU,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: originDepth }
      },
      data,
      {
        offset: image.width * image.height * bytesPerTexel * depth,
        bytesPerRow
      },
      {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 1
      }
    );
    if (flipY === true) {
      this._flipY(textureGPU, textureDescriptorGPU, originDepth);
    }
  }
  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {
    const device = this.backend.device;
    const blockData = this._getBlockData(textureDescriptorGPU.format);
    for (let i = 0; i < mipmaps.length; i++) {
      const mipmap = mipmaps[i];
      const width = mipmap.width;
      const height = mipmap.height;
      const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;
      device.queue.writeTexture(
        {
          texture: textureGPU,
          mipLevel: i
        },
        mipmap.data,
        {
          offset: 0,
          bytesPerRow
        },
        {
          width: Math.ceil(width / blockData.width) * blockData.width,
          height: Math.ceil(height / blockData.width) * blockData.width,
          depthOrArrayLayers: 1
        }
      );
    }
  }
  _getBlockData(format) {
    if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACR11Unorm)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACR11Snorm)
      return { byteLength: 8, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACRG11Unorm)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.EACRG11Snorm)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB)
      return { byteLength: 16, width: 4, height: 4 };
    if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB)
      return { byteLength: 16, width: 5, height: 4 };
    if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB)
      return { byteLength: 16, width: 5, height: 5 };
    if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB)
      return { byteLength: 16, width: 6, height: 5 };
    if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB)
      return { byteLength: 16, width: 6, height: 6 };
    if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB)
      return { byteLength: 16, width: 8, height: 5 };
    if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB)
      return { byteLength: 16, width: 8, height: 6 };
    if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB)
      return { byteLength: 16, width: 8, height: 8 };
    if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB)
      return { byteLength: 16, width: 10, height: 5 };
    if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB)
      return { byteLength: 16, width: 10, height: 6 };
    if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB)
      return { byteLength: 16, width: 10, height: 8 };
    if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB)
      return { byteLength: 16, width: 10, height: 10 };
    if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB)
      return { byteLength: 16, width: 12, height: 10 };
    if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB)
      return { byteLength: 16, width: 12, height: 12 };
  }
  _convertAddressMode(value) {
    let addressMode = GPUAddressMode.ClampToEdge;
    if (value === RepeatWrapping) {
      addressMode = GPUAddressMode.Repeat;
    } else if (value === MirroredRepeatWrapping) {
      addressMode = GPUAddressMode.MirrorRepeat;
    }
    return addressMode;
  }
  _convertFilterMode(value) {
    let filterMode = GPUFilterMode.Linear;
    if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {
      filterMode = GPUFilterMode.Nearest;
    }
    return filterMode;
  }
  _getBytesPerTexel(format) {
    if (format === GPUTextureFormat.R8Unorm)
      return 1;
    if (format === GPUTextureFormat.R16Float)
      return 2;
    if (format === GPUTextureFormat.RG8Unorm)
      return 2;
    if (format === GPUTextureFormat.RG16Float)
      return 4;
    if (format === GPUTextureFormat.R32Float)
      return 4;
    if (format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB)
      return 4;
    if (format === GPUTextureFormat.RG32Float)
      return 8;
    if (format === GPUTextureFormat.RGBA16Float)
      return 8;
    if (format === GPUTextureFormat.RGBA32Float)
      return 16;
  }
  _getTypedArrayType(format) {
    if (format === GPUTextureFormat.R8Uint)
      return Uint8Array;
    if (format === GPUTextureFormat.R8Sint)
      return Int8Array;
    if (format === GPUTextureFormat.R8Unorm)
      return Uint8Array;
    if (format === GPUTextureFormat.R8Snorm)
      return Int8Array;
    if (format === GPUTextureFormat.RG8Uint)
      return Uint8Array;
    if (format === GPUTextureFormat.RG8Sint)
      return Int8Array;
    if (format === GPUTextureFormat.RG8Unorm)
      return Uint8Array;
    if (format === GPUTextureFormat.RG8Snorm)
      return Int8Array;
    if (format === GPUTextureFormat.RGBA8Uint)
      return Uint8Array;
    if (format === GPUTextureFormat.RGBA8Sint)
      return Int8Array;
    if (format === GPUTextureFormat.RGBA8Unorm)
      return Uint8Array;
    if (format === GPUTextureFormat.RGBA8Snorm)
      return Int8Array;
    if (format === GPUTextureFormat.R16Uint)
      return Uint16Array;
    if (format === GPUTextureFormat.R16Sint)
      return Int16Array;
    if (format === GPUTextureFormat.RG16Uint)
      return Uint16Array;
    if (format === GPUTextureFormat.RG16Sint)
      return Int16Array;
    if (format === GPUTextureFormat.RGBA16Uint)
      return Uint16Array;
    if (format === GPUTextureFormat.RGBA16Sint)
      return Int16Array;
    if (format === GPUTextureFormat.R32Uint)
      return Uint32Array;
    if (format === GPUTextureFormat.R32Sint)
      return Int32Array;
    if (format === GPUTextureFormat.R32Float)
      return Float32Array;
    if (format === GPUTextureFormat.RG32Uint)
      return Uint32Array;
    if (format === GPUTextureFormat.RG32Sint)
      return Int32Array;
    if (format === GPUTextureFormat.RG32Float)
      return Float32Array;
    if (format === GPUTextureFormat.RGBA32Uint)
      return Uint32Array;
    if (format === GPUTextureFormat.RGBA32Sint)
      return Int32Array;
    if (format === GPUTextureFormat.RGBA32Float)
      return Float32Array;
  }
  _getDimension(texture2) {
    let dimension;
    if (texture2.isData3DTexture) {
      dimension = GPUTextureDimension.ThreeD;
    } else {
      dimension = GPUTextureDimension.TwoD;
    }
    return dimension;
  }
};
function getFormat(texture2, device = null) {
  const format = texture2.format;
  const type = texture2.type;
  const colorSpace = texture2.colorSpace;
  let formatGPU;
  if (
    /*texture.isRenderTargetTexture === true ||*/
    texture2.isFramebufferTexture === true
  ) {
    formatGPU = GPUTextureFormat.BGRA8Unorm;
  } else if (texture2.isCompressedTexture === true) {
    switch (format) {
      case RGBA_S3TC_DXT1_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
        break;
      case RGBA_S3TC_DXT3_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
        break;
      case RGBA_S3TC_DXT5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
        break;
      case RGB_ETC2_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
        break;
      case RGBA_ETC2_EAC_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
        break;
      case RGBA_ASTC_4x4_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
        break;
      case RGBA_ASTC_5x4_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
        break;
      case RGBA_ASTC_5x5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
        break;
      case RGBA_ASTC_6x5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
        break;
      case RGBA_ASTC_6x6_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
        break;
      case RGBA_ASTC_8x5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
        break;
      case RGBA_ASTC_8x6_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
        break;
      case RGBA_ASTC_8x8_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
        break;
      case RGBA_ASTC_10x5_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
        break;
      case RGBA_ASTC_10x6_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
        break;
      case RGBA_ASTC_10x8_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
        break;
      case RGBA_ASTC_10x10_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
        break;
      case RGBA_ASTC_12x10_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
        break;
      case RGBA_ASTC_12x12_Format:
        formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", format);
    }
  } else {
    switch (format) {
      case RGBAFormat:
        switch (type) {
          case UnsignedByteType:
            formatGPU = colorSpace === SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RGBA16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RGBA32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", type);
        }
        break;
      case RedFormat:
        switch (type) {
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.R8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.R16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.R32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedFormat.", type);
        }
        break;
      case RGFormat:
        switch (type) {
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.RG8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RG16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RG32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGFormat.", type);
        }
        break;
      case DepthFormat:
        switch (type) {
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.Depth16Unorm;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.Depth24Plus;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.Depth32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", type);
        }
        break;
      case DepthStencilFormat:
        switch (type) {
          case UnsignedInt248Type:
            formatGPU = GPUTextureFormat.Depth24PlusStencil8;
            break;
          case FloatType:
            if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {
              console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.');
            }
            formatGPU = GPUTextureFormat.Depth32FloatStencil8;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", type);
        }
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", format);
    }
  }
  return formatGPU;
}
var WebGPUTextureUtils_default = WebGPUTextureUtils;

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeFunction.js
var declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+)?/i;
var propertiesRegexp = /[a-z_0-9]+|<(.*?)>+/ig;
var wgslTypeLib = {
  f32: "float"
};
var parse = (source) => {
  source = source.trim();
  const declaration = source.match(declarationRegexp);
  if (declaration !== null && declaration.length === 4) {
    const inputsCode = declaration[2];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const name2 = propsMatches[i++][0];
      let type2 = propsMatches[i++][0];
      type2 = wgslTypeLib[type2] || type2;
      if (i < propsMatches.length && propsMatches[i][0].startsWith("<") === true)
        i++;
      inputs.push(new NodeFunctionInput_default(type2, name2));
    }
    const blockCode = source.substring(declaration[0].length);
    const name = declaration[1] !== void 0 ? declaration[1] : "";
    const type = declaration[3] || "void";
    return {
      type,
      inputs,
      name,
      inputsCode,
      blockCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a WGSL code.");
  }
};
var WGSLNodeFunction = class extends NodeFunction_default {
  constructor(source) {
    const { type, inputs, name, inputsCode, blockCode } = parse(source);
    super(type, inputs, name);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
  }
  getCode(name = this.name) {
    const type = this.type !== "void" ? "-> " + this.type : "";
    return `fn ${name} ( ${this.inputsCode.trim()} ) ${type}` + this.blockCode;
  }
};
var WGSLNodeFunction_default = WGSLNodeFunction;

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeParser.js
var WGSLNodeParser = class extends NodeParser_default {
  parseFunction(source) {
    return new WGSLNodeFunction_default(source);
  }
};
var WGSLNodeParser_default = WGSLNodeParser;

// node_modules/three/examples/jsm/renderers/webgpu/nodes/WGSLNodeBuilder.js
var gpuShaderStageLib = {
  "vertex": GPUShaderStage.VERTEX,
  "fragment": GPUShaderStage.FRAGMENT,
  "compute": GPUShaderStage.COMPUTE
};
var supports2 = {
  instance: true
};
var wgslFnOpLib = {
  "^^": "threejs_xor"
};
var wgslTypeLib2 = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat3: "mat3x3<f32>",
  imat3: "mat3x3<i32>",
  umat3: "mat3x3<u32>",
  bmat3: "mat3x3<bool>",
  mat4: "mat4x4<f32>",
  imat4: "mat4x4<i32>",
  umat4: "mat4x4<u32>",
  bmat4: "mat4x4<bool>"
};
var wgslMethods = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod: "threejs_mod",
  lessThanEqual: "threejs_lessThanEqual",
  greaterThan: "threejs_greaterThan",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>"
};
var wgslPolyfill = {
  threejs_xor: new CodeNode_default(`
fn threejs_xor( a : bool, b : bool ) -> bool {

	return ( a || b ) && !( a && b );

}
`),
  lessThanEqual: new CodeNode_default(`
fn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {

	return vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );

}
`),
  greaterThan: new CodeNode_default(`
fn threejs_greaterThan( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {

	return vec3<bool>( a.x > b.x, a.y > b.y, a.z > b.z );

}
`),
  mod: new CodeNode_default(`
fn threejs_mod( x : f32, y : f32 ) -> f32 {

	return x - y * floor( x / y );

}
`),
  repeatWrapping: new CodeNode_default(`
fn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
`)
};
var WGSLNodeBuilder = class extends NodeBuilder_default {
  constructor(object, renderer, scene = null) {
    super(object, renderer, new WGSLNodeParser_default(), scene);
    this.uniformGroups = {};
    this.builtins = {};
  }
  build() {
    const { object, material } = this;
    if (material !== null) {
      NodeMaterial_default.fromMaterial(material).build(this);
    } else {
      this.addFlow("compute", object);
    }
    return super.build();
  }
  needsColorSpaceToLinear(texture2) {
    return texture2.isVideoTexture === true && texture2.colorSpace !== NoColorSpace;
  }
  _generateTextureSample(texture2, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (depthSnippet) {
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
      } else {
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;
      }
    } else {
      return this.generateTextureLod(texture2, textureProperty, uvSnippet);
    }
  }
  _generateVideoSample(textureProperty, uvSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;
    } else {
      console.error(`WebGPURenderer: THREE.VideoTexture does not support ${shaderStage} shader.`);
    }
  }
  _generateTextureSampleLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment" && this.isUnfilterable(texture2) === false) {
      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
    } else {
      return this.generateTextureLod(texture2, textureProperty, uvSnippet, levelSnippet);
    }
  }
  generateTextureLod(texture2, textureProperty, uvSnippet, levelSnippet = "0") {
    this._include("repeatWrapping");
    const dimension = `textureDimensions( ${textureProperty}, 0 )`;
    return `textureLoad( ${textureProperty}, threejs_repeatWrapping( ${uvSnippet}, ${dimension} ), i32( ${levelSnippet} ) )`;
  }
  generateTextureLoad(texture2, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = "0u") {
    if (depthSnippet) {
      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${levelSnippet} )`;
    } else {
      return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
    }
  }
  isUnfilterable(texture2) {
    return texture2.isDataTexture === true && texture2.type === FloatType;
  }
  generateTexture(texture2, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage) {
    let snippet = null;
    if (texture2.isVideoTexture === true) {
      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);
    } else if (this.isUnfilterable(texture2)) {
      snippet = this.generateTextureLod(texture2, textureProperty, uvSnippet, "0", depthSnippet, shaderStage);
    } else {
      snippet = this._generateTextureSample(texture2, textureProperty, uvSnippet, depthSnippet, shaderStage);
    }
    return snippet;
  }
  generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;
    } else {
      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
    }
  }
  generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage) {
    let snippet = null;
    if (texture2.isVideoTexture === true) {
      snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);
    } else {
      snippet = this._generateTextureSampleLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage);
    }
    return snippet;
  }
  getPropertyName(node, shaderStage = this.shaderStage) {
    if (node.isNodeVarying === true && node.needsInterpolation === true) {
      if (shaderStage === "vertex") {
        return `varyings.${node.name}`;
      }
    } else if (node.isNodeUniform === true) {
      const name = node.name;
      const type = node.type;
      if (type === "texture" || type === "cubeTexture") {
        return name;
      } else if (type === "buffer" || type === "storageBuffer") {
        return `NodeBuffer_${node.id}.${name}`;
      } else {
        return node.groupNode.name + "." + name;
      }
    }
    return super.getPropertyName(node);
  }
  _getUniformGroupCount(shaderStage) {
    return Object.keys(this.uniforms[shaderStage]).length;
  }
  getFunctionOperator(op) {
    const fnOp = wgslFnOpLib[op];
    if (fnOp !== void 0) {
      this._include(fnOp);
      return fnOp;
    }
    return null;
  }
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    if (nodeData.uniformGPU === void 0) {
      let uniformGPU;
      const bindings = this.bindings[shaderStage];
      if (type === "texture" || type === "cubeTexture") {
        let texture2 = null;
        if (type === "texture") {
          texture2 = new NodeSampledTexture(uniformNode.name, uniformNode.node);
        } else if (type === "cubeTexture") {
          texture2 = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node);
        }
        texture2.store = node.isStoreTextureNode === true;
        texture2.setVisibility(gpuShaderStageLib[shaderStage]);
        if (shaderStage === "fragment" && this.isUnfilterable(node.value) === false && texture2.store === false) {
          const sampler = new NodeSampler_default(`${uniformNode.name}_sampler`, uniformNode.node);
          sampler.setVisibility(gpuShaderStageLib[shaderStage]);
          bindings.push(sampler, texture2);
          uniformGPU = [sampler, texture2];
        } else {
          bindings.push(texture2);
          uniformGPU = [texture2];
        }
      } else if (type === "buffer" || type === "storageBuffer") {
        const bufferClass = type === "storageBuffer" ? StorageBuffer_default : UniformBuffer_default;
        const buffer = new bufferClass("NodeBuffer_" + node.id, node.value);
        buffer.setVisibility(gpuShaderStageLib[shaderStage]);
        bindings.push(buffer);
        uniformGPU = buffer;
      } else {
        const group = node.groupNode;
        const groupName = group.name;
        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup_default(groupName, group);
          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);
          uniformsStage[groupName] = uniformsGroup;
          bindings.push(uniformsGroup);
        }
        if (node.isArrayUniformNode === true) {
          uniformGPU = [];
          for (const uniformNode2 of node.nodes) {
            const uniformNodeGPU = this.getNodeUniform(uniformNode2, type);
            uniformNodeGPU.boundary = getVectorLength(uniformNodeGPU.itemSize);
            uniformNodeGPU.itemSize = getStrideLength(uniformNodeGPU.itemSize);
            uniformsGroup.addUniform(uniformNodeGPU);
            uniformGPU.push(uniformNodeGPU);
          }
        } else {
          uniformGPU = this.getNodeUniform(uniformNode, type);
          uniformsGroup.addUniform(uniformGPU);
        }
      }
      nodeData.uniformGPU = uniformGPU;
      if (shaderStage === "vertex") {
        this.bindingsOffset["fragment"] = bindings.length;
      }
    }
    return uniformNode;
  }
  isReference(type) {
    return super.isReference(type) || type === "texture_2d" || type === "texture_cube" || type === "texture_depth_2d" || type === "texture_storage_2d";
  }
  getBuiltin(name, property, type, shaderStage = this.shaderStage) {
    const map = this.builtins[shaderStage] || (this.builtins[shaderStage] = /* @__PURE__ */ new Map());
    if (map.has(name) === false) {
      map.set(name, {
        name,
        property,
        type
      });
    }
    return property;
  }
  getVertexIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute");
    }
    return "vertexIndex";
  }
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(input.name + " : " + this.getType(input.type));
    }
    const code = `fn ${layout.name}( ${parameters.join(", ")} ) -> ${this.getType(layout.type)} {
${flowData.vars}
${flowData.code}
	return ${flowData.result};

}`;
    return code;
  }
  getInstanceIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute");
    }
    return "instanceIndex";
  }
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  isFlipY() {
    return false;
  }
  getBuiltins(shaderStage) {
    const snippets = [];
    const builtins = this.builtins[shaderStage];
    if (builtins !== void 0) {
      for (const { name, property, type } of builtins.values()) {
        snippets.push(`@builtin( ${name} ) ${property} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  getAttributes(shaderStage) {
    const snippets = [];
    if (shaderStage === "compute") {
      this.getBuiltin("global_invocation_id", "id", "vec3<u32>", "attribute");
    }
    if (shaderStage === "vertex" || shaderStage === "compute") {
      const builtins = this.getBuiltins("attribute");
      if (builtins)
        snippets.push(builtins);
      const attributes = this.getAttributesArray();
      for (let index = 0, length = attributes.length; index < length; index++) {
        const attribute = attributes[index];
        const name = attribute.name;
        const type = this.getType(attribute.type);
        snippets.push(`@location( ${index} ) ${name} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  getStructMembers(struct) {
    const snippets = [];
    const members = struct.getMemberTypes();
    for (let i = 0; i < members.length; i++) {
      const member = members[i];
      snippets.push(`	@location( ${i} ) m${i} : ${member}<f32>`);
    }
    return snippets.join(",\n");
  }
  getStructs(shaderStage) {
    const snippets = [];
    const structs = this.structs[shaderStage];
    for (let index = 0, length = structs.length; index < length; index++) {
      const struct = structs[index];
      const name = struct.name;
      let snippet = `struct ${name} {
`;
      snippet += this.getStructMembers(struct);
      snippet += "\n}";
      snippets.push(snippet);
    }
    return snippets.join("\n\n");
  }
  getVar(type, name) {
    return `var ${name} : ${this.getType(type)}`;
  }
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippets.push(`	${this.getVar(variable.type, variable.name)};`);
      }
    }
    return `
${snippets.join("\n")}
`;
  }
  getVaryings(shaderStage) {
    const snippets = [];
    if (shaderStage === "vertex") {
      this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex");
    }
    if (shaderStage === "vertex" || shaderStage === "fragment") {
      const varyings = this.varyings;
      const vars = this.vars[shaderStage];
      for (let index = 0; index < varyings.length; index++) {
        const varying = varyings[index];
        if (varying.needsInterpolation) {
          let attributesSnippet = `@location( ${index} )`;
          if (/^(int|uint|ivec|uvec)/.test(varying.type)) {
            attributesSnippet += " @interpolate( flat )";
          }
          snippets.push(`${attributesSnippet} ${varying.name} : ${this.getType(varying.type)}`);
        } else if (shaderStage === "vertex" && vars.includes(varying) === false) {
          vars.push(varying);
        }
      }
    }
    const builtins = this.getBuiltins(shaderStage);
    if (builtins)
      snippets.push(builtins);
    const code = snippets.join(",\n	");
    return shaderStage === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + code) : code;
  }
  getUniforms(shaderStage) {
    const uniforms = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const bufferSnippets = [];
    const structSnippets = [];
    const uniformGroups = {};
    let index = this.bindingsOffset[shaderStage];
    for (const uniform of uniforms) {
      if (uniform.type === "texture" || uniform.type === "cubeTexture") {
        const texture2 = uniform.node.value;
        if (shaderStage === "fragment" && this.isUnfilterable(texture2) === false && uniform.node.isStoreTextureNode !== true) {
          if (texture2.isDepthTexture === true && texture2.compareFunction !== null) {
            bindingSnippets.push(`@binding( ${index++} ) @group( 0 ) var ${uniform.name}_sampler : sampler_comparison;`);
          } else {
            bindingSnippets.push(`@binding( ${index++} ) @group( 0 ) var ${uniform.name}_sampler : sampler;`);
          }
        }
        let textureType;
        if (texture2.isCubeTexture === true) {
          textureType = "texture_cube<f32>";
        } else if (texture2.isDataArrayTexture === true) {
          textureType = "texture_2d_array<f32>";
        } else if (texture2.isDepthTexture === true) {
          textureType = "texture_depth_2d";
        } else if (texture2.isVideoTexture === true) {
          textureType = "texture_external";
        } else if (uniform.node.isStoreTextureNode === true) {
          const format = getFormat(texture2);
          textureType = "texture_storage_2d<" + format + ", write>";
        } else {
          textureType = "texture_2d<f32>";
        }
        bindingSnippets.push(`@binding( ${index++} ) @group( 0 ) var ${uniform.name} : ${textureType};`);
      } else if (uniform.type === "buffer" || uniform.type === "storageBuffer") {
        const bufferNode = uniform.node;
        const bufferType = this.getType(bufferNode.bufferType);
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 ? ", " + bufferCount : "";
        const bufferSnippet = `	${uniform.name} : array< ${bufferType}${bufferCountSnippet} >
`;
        const bufferAccessMode = bufferNode.isStorageBufferNode ? "storage,read_write" : "uniform";
        bufferSnippets.push(this._getWGSLStructBinding("NodeBuffer_" + bufferNode.id, bufferSnippet, bufferAccessMode, index++));
      } else {
        const vectorType = this.getType(this.getVectorType(uniform.type));
        const groupName = uniform.groupNode.name;
        const group = uniformGroups[groupName] || (uniformGroups[groupName] = {
          index: index++,
          snippets: []
        });
        if (Array.isArray(uniform.value) === true) {
          const length = uniform.value.length;
          group.snippets.push(`uniform ${vectorType}[ ${length} ] ${uniform.name}`);
        } else {
          group.snippets.push(`	${uniform.name} : ${vectorType}`);
        }
      }
    }
    for (const name in uniformGroups) {
      const group = uniformGroups[name];
      structSnippets.push(this._getWGSLStructBinding(name, group.snippets.join(",\n"), "uniform", group.index));
    }
    let code = bindingSnippets.join("\n");
    code += bufferSnippets.join("\n");
    code += structSnippets.join("\n");
    return code;
  }
  buildCode() {
    const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    for (const shaderStage in shadersData) {
      const stageData = shadersData[shaderStage];
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      let flow = "// code\n\n";
      flow += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      const outputNode = mainNode.outputNode;
      const isOutputStruct = outputNode !== void 0 && outputNode.isOutputStructNode === true;
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow.length > 0)
            flow += "\n";
          flow += `	// flow -> ${slotName}
	`;
        }
        flow += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow += "// result\n\n	";
          if (shaderStage === "vertex") {
            flow += `varyings.Vertex = ${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (isOutputStruct) {
              stageData.returnType = outputNode.nodeType;
              flow += `return ${flowSlotData.result};`;
            } else {
              let structSnippet = "	@location(0) color: vec4<f32>";
              const builtins = this.getBuiltins("output");
              if (builtins)
                structSnippet += ",\n	" + builtins;
              stageData.returnType = "OutputStruct";
              stageData.structs += this._getWGSLStruct("OutputStruct", structSnippet);
              stageData.structs += "\nvar<private> output : OutputStruct;\n\n";
              flow += `output.color = ${flowSlotData.result};

	return output;`;
            }
          }
        }
      }
      stageData.flow = flow;
    }
    if (this.material !== null) {
      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);
    } else {
      this.computeShader = this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || [64]).join(", "));
    }
  }
  getMethod(method) {
    if (wgslPolyfill[method] !== void 0) {
      this._include(method);
    }
    return wgslMethods[method] || method;
  }
  getType(type) {
    return wgslTypeLib2[type] || type;
  }
  isAvailable(name) {
    return supports2[name] === true;
  }
  _include(name) {
    const codeNode = wgslPolyfill[name];
    codeNode.build(this);
    if (this.currentFunctionNode !== null) {
      this.currentFunctionNode.includes.push(codeNode);
    }
    return codeNode;
  }
  _getWGSLVertexCode(shaderData) {
    return `${this.getSignature()}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;
  }
  _getWGSLFragmentCode(shaderData) {
    return `${this.getSignature()}

// uniforms
${shaderData.uniforms}

// structs
${shaderData.structs}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  _getWGSLComputeCode(shaderData, workgroupSize) {
    return `${this.getSignature()}
// system
var<private> instanceIndex : u32;

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = id.x;

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  _getWGSLStruct(name, vars) {
    return `
struct ${name} {
${vars}
};`;
  }
  _getWGSLStructBinding(name, vars, access, binding = 0, group = 0) {
    const structName = name + "Struct";
    const structSnippet = this._getWGSLStruct(structName, vars);
    return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;
  }
};
var WGSLNodeBuilder_default = WGSLNodeBuilder;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUUtils.js
var WebGPUUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  getCurrentDepthStencilFormat(renderContext) {
    let format;
    if (renderContext.depthTexture !== null) {
      format = this.getTextureFormatGPU(renderContext.depthTexture);
    } else if (renderContext.depth && renderContext.stencil) {
      format = GPUTextureFormat.Depth24PlusStencil8;
    } else if (renderContext.depth) {
      format = GPUTextureFormat.Depth24Plus;
    }
    return format;
  }
  getTextureFormatGPU(texture2) {
    return this.backend.get(texture2).texture.format;
  }
  getCurrentColorFormat(renderContext) {
    let format;
    if (renderContext.textures !== null) {
      format = this.getTextureFormatGPU(renderContext.textures[0]);
    } else {
      format = GPUTextureFormat.BGRA8Unorm;
    }
    return format;
  }
  getCurrentColorSpace(renderContext) {
    if (renderContext.textures !== null) {
      return renderContext.textures[0].colorSpace;
    }
    return this.backend.renderer.outputColorSpace;
  }
  getPrimitiveTopology(object, material) {
    if (object.isPoints)
      return GPUPrimitiveTopology.PointList;
    else if (object.isLineSegments || object.isMesh && material.wireframe === true)
      return GPUPrimitiveTopology.LineList;
    else if (object.isLine)
      return GPUPrimitiveTopology.LineStrip;
    else if (object.isMesh)
      return GPUPrimitiveTopology.TriangleList;
  }
  getSampleCount(renderContext) {
    if (renderContext.textures !== null) {
      return renderContext.sampleCount;
    }
    return this.backend.parameters.sampleCount;
  }
};
var WebGPUUtils_default = WebGPUUtils;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUAttributeUtils.js
var typedArraysToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]);
var typedAttributeToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Float16BufferAttribute, ["float16"]]
]);
var typeArraysToVertexFormatPrefixForItemSize1 = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Uint32Array, "uint32"],
  [Float32Array, "float32"]
]);
var WebGPUAttributeUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  createAttribute(attribute, usage) {
    const bufferAttribute = this._getBufferAttribute(attribute);
    const backend = this.backend;
    const bufferData = backend.get(bufferAttribute);
    let buffer = bufferData.buffer;
    if (buffer === void 0) {
      const device = backend.device;
      const array = bufferAttribute.array;
      const size = array.byteLength + (4 - array.byteLength % 4) % 4;
      buffer = device.createBuffer({
        label: bufferAttribute.name,
        size,
        usage,
        mappedAtCreation: true
      });
      new array.constructor(buffer.getMappedRange()).set(array);
      buffer.unmap();
      bufferData.buffer = buffer;
    }
  }
  updateAttribute(attribute) {
    const bufferAttribute = this._getBufferAttribute(attribute);
    const backend = this.backend;
    const device = backend.device;
    const buffer = backend.get(bufferAttribute).buffer;
    const array = bufferAttribute.array;
    const updateRanges = bufferAttribute.updateRanges;
    if (updateRanges.length === 0) {
      device.queue.writeBuffer(
        buffer,
        0,
        array,
        0
      );
    } else {
      for (let i = 0, l = updateRanges.length; i < l; i++) {
        const range = updateRanges[i];
        device.queue.writeBuffer(
          buffer,
          0,
          array,
          range.start * array.BYTES_PER_ELEMENT,
          range.count * array.BYTES_PER_ELEMENT
        );
      }
      bufferAttribute.clearUpdateRanges();
    }
  }
  createShaderVertexBuffers(renderObject) {
    const attributes = renderObject.getAttributes();
    const vertexBuffers = /* @__PURE__ */ new Map();
    for (let slot = 0; slot < attributes.length; slot++) {
      const geometryAttribute = attributes[slot];
      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
      const bufferAttribute = this._getBufferAttribute(geometryAttribute);
      let vertexBufferLayout = vertexBuffers.get(bufferAttribute);
      if (vertexBufferLayout === void 0) {
        let arrayStride, stepMode;
        if (geometryAttribute.isInterleavedBufferAttribute === true) {
          arrayStride = geometryAttribute.data.stride * bytesPerElement;
          stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
        } else {
          arrayStride = geometryAttribute.itemSize * bytesPerElement;
          stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
        }
        vertexBufferLayout = {
          arrayStride,
          attributes: [],
          stepMode
        };
        vertexBuffers.set(bufferAttribute, vertexBufferLayout);
      }
      const format = this._getVertexFormat(geometryAttribute);
      const offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;
      vertexBufferLayout.attributes.push({
        shaderLocation: slot,
        offset,
        format
      });
    }
    return Array.from(vertexBuffers.values());
  }
  destroyAttribute(attribute) {
    const backend = this.backend;
    const data = backend.get(this._getBufferAttribute(attribute));
    data.buffer.destroy();
    backend.delete(attribute);
  }
  async getArrayBufferAsync(attribute) {
    const backend = this.backend;
    const device = backend.device;
    const data = backend.get(this._getBufferAttribute(attribute));
    const bufferGPU = data.buffer;
    const size = bufferGPU.size;
    let readBufferGPU = data.readBuffer;
    let needsUnmap = true;
    if (readBufferGPU === void 0) {
      readBufferGPU = device.createBuffer({
        label: attribute.name,
        size,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
      needsUnmap = false;
      data.readBuffer = readBufferGPU;
    }
    const cmdEncoder = device.createCommandEncoder({});
    cmdEncoder.copyBufferToBuffer(
      bufferGPU,
      0,
      readBufferGPU,
      0,
      size
    );
    if (needsUnmap)
      readBufferGPU.unmap();
    const gpuCommands = cmdEncoder.finish();
    device.queue.submit([gpuCommands]);
    await readBufferGPU.mapAsync(GPUMapMode.READ);
    const arrayBuffer = readBufferGPU.getMappedRange();
    return arrayBuffer;
  }
  _getVertexFormat(geometryAttribute) {
    const { itemSize, normalized } = geometryAttribute;
    const ArrayType = geometryAttribute.array.constructor;
    const AttributeType2 = geometryAttribute.constructor;
    let format;
    if (itemSize == 1) {
      format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);
    } else {
      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType2) || typedArraysToVertexFormatPrefix.get(ArrayType);
      const prefix = prefixOptions[normalized ? 1 : 0];
      if (prefix) {
        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;
        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;
        if (paddedItemSize % 1) {
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        }
        format = `${prefix}x${paddedItemSize}`;
      }
    }
    if (!format) {
      console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet.");
    }
    return format;
  }
  _getBufferAttribute(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return attribute;
  }
};
var WebGPUAttributeUtils_default = WebGPUAttributeUtils;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUBindingUtils.js
var WebGPUBindingUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  createBindingsLayout(bindings) {
    const backend = this.backend;
    const device = backend.device;
    const entries = [];
    let index = 0;
    for (const binding of bindings) {
      const bindingGPU = {
        binding: index++,
        visibility: binding.visibility
      };
      if (binding.isUniformBuffer || binding.isStorageBuffer) {
        const buffer = {};
        if (binding.isStorageBuffer) {
          buffer.type = GPUBufferBindingType.Storage;
        }
        bindingGPU.buffer = buffer;
      } else if (binding.isSampler) {
        const sampler = {};
        if (binding.texture.isDepthTexture) {
          if (binding.texture.compareFunction !== null) {
            sampler.type = "comparison";
          }
        }
        bindingGPU.sampler = sampler;
      } else if (binding.isSampledTexture && binding.texture.isVideoTexture) {
        bindingGPU.externalTexture = {};
      } else if (binding.isSampledTexture && binding.store) {
        const format = this.backend.get(binding.texture).texture.format;
        bindingGPU.storageTexture = { format };
      } else if (binding.isSampledTexture) {
        const texture2 = {};
        if (binding.texture.isDepthTexture) {
          texture2.sampleType = GPUTextureSampleType.Depth;
        } else if (binding.texture.isDataTexture && binding.texture.type === FloatType) {
          texture2.sampleType = GPUTextureSampleType.UnfilterableFloat;
        }
        if (binding.isSampledCubeTexture) {
          texture2.viewDimension = GPUTextureViewDimension.Cube;
        } else if (binding.texture.isDataArrayTexture) {
          texture2.viewDimension = GPUTextureViewDimension.TwoDArray;
        }
        bindingGPU.texture = texture2;
      } else {
        console.error(`WebGPUBindingUtils: Unsupported binding "${binding}".`);
      }
      entries.push(bindingGPU);
    }
    return device.createBindGroupLayout({ entries });
  }
  createBindings(bindings) {
    const backend = this.backend;
    const bindingsData = backend.get(bindings);
    const bindLayoutGPU = this.createBindingsLayout(bindings);
    const bindGroupGPU = this.createBindGroup(bindings, bindLayoutGPU);
    bindingsData.layout = bindLayoutGPU;
    bindingsData.group = bindGroupGPU;
    bindingsData.bindings = bindings;
  }
  updateBinding(binding) {
    const backend = this.backend;
    const device = backend.device;
    const buffer = binding.buffer;
    const bufferGPU = backend.get(binding).buffer;
    device.queue.writeBuffer(bufferGPU, 0, buffer, 0);
  }
  createBindGroup(bindings, layoutGPU) {
    const backend = this.backend;
    const device = backend.device;
    let bindingPoint = 0;
    const entriesGPU = [];
    for (const binding of bindings) {
      if (binding.isUniformBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const byteLength = binding.byteLength;
          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
          const bufferGPU = device.createBuffer({
            label: "bindingBuffer_" + binding.name,
            size: byteLength,
            usage
          });
          bindingData.buffer = bufferGPU;
        }
        entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
      } else if (binding.isStorageBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const attribute = binding.attribute;
          bindingData.buffer = backend.get(attribute).buffer;
        }
        entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
      } else if (binding.isSampler) {
        const textureGPU = backend.get(binding.texture);
        entriesGPU.push({ binding: bindingPoint, resource: textureGPU.sampler });
      } else if (binding.isSampledTexture) {
        const textureData = backend.get(binding.texture);
        let dimensionViewGPU;
        if (binding.isSampledCubeTexture) {
          dimensionViewGPU = GPUTextureViewDimension.Cube;
        } else if (binding.texture.isDataArrayTexture) {
          dimensionViewGPU = GPUTextureViewDimension.TwoDArray;
        } else {
          dimensionViewGPU = GPUTextureViewDimension.TwoD;
        }
        let resourceGPU;
        if (textureData.externalTexture !== void 0) {
          resourceGPU = device.importExternalTexture({ source: textureData.externalTexture });
        } else {
          const aspectGPU = GPUTextureAspect.All;
          resourceGPU = textureData.texture.createView({ aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount: binding.store ? 1 : textureData.mipLevelCount });
        }
        entriesGPU.push({ binding: bindingPoint, resource: resourceGPU });
      }
      bindingPoint++;
    }
    return device.createBindGroup({
      layout: layoutGPU,
      entries: entriesGPU
    });
  }
};
var WebGPUBindingUtils_default = WebGPUBindingUtils;

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUPipelineUtils.js
var WebGPUPipelineUtils = class {
  constructor(backend) {
    this.backend = backend;
  }
  createRenderPipeline(renderObject) {
    const { object, material, geometry, pipeline } = renderObject;
    const { vertexProgram, fragmentProgram } = pipeline;
    const backend = this.backend;
    const device = backend.device;
    const utils = backend.utils;
    const pipelineData = backend.get(pipeline);
    const bindingsData = backend.get(renderObject.getBindings());
    const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);
    let blending;
    if (material.transparent === true && material.blending !== NoBlending) {
      blending = this._getBlending(material);
    }
    let stencilFront = {};
    if (material.stencilWrite === true) {
      stencilFront = {
        compare: this._getStencilCompare(material),
        failOp: this._getStencilOperation(material.stencilFail),
        depthFailOp: this._getStencilOperation(material.stencilZFail),
        passOp: this._getStencilOperation(material.stencilZPass)
      };
    }
    const colorWriteMask = this._getColorWriteMask(material);
    const targets = [];
    if (renderObject.context.textures !== null) {
      const textures = renderObject.context.textures;
      for (let i = 0; i < textures.length; i++) {
        const colorFormat = utils.getTextureFormatGPU(textures[i]);
        targets.push({
          format: colorFormat,
          blend: blending,
          writeMask: colorWriteMask
        });
      }
    } else {
      const colorFormat = utils.getCurrentColorFormat(renderObject.context);
      targets.push({
        format: colorFormat,
        blend: blending,
        writeMask: colorWriteMask
      });
    }
    const vertexModule = backend.get(vertexProgram).module;
    const fragmentModule = backend.get(fragmentProgram).module;
    const primitiveState = this._getPrimitiveState(object, geometry, material);
    const depthCompare = this._getDepthCompare(material);
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
    const sampleCount = utils.getSampleCount(renderObject.context);
    pipelineData.pipeline = device.createRenderPipeline({
      vertex: Object.assign({}, vertexModule, { buffers: vertexBuffers }),
      fragment: Object.assign({}, fragmentModule, { targets }),
      primitive: primitiveState,
      depthStencil: {
        format: depthStencilFormat,
        depthWriteEnabled: material.depthWrite,
        depthCompare,
        stencilFront,
        stencilBack: {},
        // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
        stencilReadMask: material.stencilFuncMask,
        stencilWriteMask: material.stencilWriteMask
      },
      multisample: {
        count: sampleCount,
        alphaToCoverageEnabled: material.alphaToCoverage
      },
      layout: device.createPipelineLayout({
        bindGroupLayouts: [bindingsData.layout]
      })
    });
  }
  createComputePipeline(pipeline, bindings) {
    const backend = this.backend;
    const device = backend.device;
    const computeProgram = backend.get(pipeline.computeProgram).module;
    const pipelineGPU = backend.get(pipeline);
    const bindingsData = backend.get(bindings);
    pipelineGPU.pipeline = device.createComputePipeline({
      compute: computeProgram,
      layout: device.createPipelineLayout({
        bindGroupLayouts: [bindingsData.layout]
      })
    });
  }
  _getBlending(material) {
    let color, alpha;
    const blending = material.blending;
    if (blending === CustomBlending) {
      const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : GPUBlendFactor.One;
      const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : GPUBlendFactor.Zero;
      const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : GPUBlendFactor.Add;
      color = {
        srcFactor: this._getBlendFactor(material.blendSrc),
        dstFactor: this._getBlendFactor(material.blendDst),
        operation: this._getBlendOperation(material.blendEquation)
      };
      alpha = {
        srcFactor: this._getBlendFactor(blendSrcAlpha),
        dstFactor: this._getBlendFactor(blendDstAlpha),
        operation: this._getBlendOperation(blendEquationAlpha)
      };
    } else {
      const premultipliedAlpha = material.premultipliedAlpha;
      const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {
        color = {
          srcFactor: srcRGB,
          dstFactor: dstRGB,
          operation: GPUBlendOperation.Add
        };
        alpha = {
          srcFactor: srcAlpha,
          dstFactor: dstAlpha,
          operation: GPUBlendOperation.Add
        };
      };
      if (premultipliedAlpha) {
        switch (blending) {
          case NormalBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
            break;
          case AdditiveBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
            break;
          case SubtractiveBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
            break;
          case MultiplyBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha);
            break;
        }
      } else {
        switch (blending) {
          case NormalBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
            break;
          case AdditiveBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One);
            break;
          case SubtractiveBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
            break;
          case MultiplyBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src);
            break;
        }
      }
    }
    if (color !== void 0 && alpha !== void 0) {
      return { color, alpha };
    } else {
      console.error("THREE.WebGPURenderer: Invalid blending: ", blending);
    }
  }
  _getBlendFactor(blend) {
    let blendFactor;
    switch (blend) {
      case ZeroFactor:
        blendFactor = GPUBlendFactor.Zero;
        break;
      case OneFactor:
        blendFactor = GPUBlendFactor.One;
        break;
      case SrcColorFactor:
        blendFactor = GPUBlendFactor.Src;
        break;
      case OneMinusSrcColorFactor:
        blendFactor = GPUBlendFactor.OneMinusSrc;
        break;
      case SrcAlphaFactor:
        blendFactor = GPUBlendFactor.SrcAlpha;
        break;
      case OneMinusSrcAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
        break;
      case DstColorFactor:
        blendFactor = GPUBlendFactor.Dst;
        break;
      case OneMinusDstColorFactor:
        blendFactor = GPUBlendFactor.OneMinusDstColor;
        break;
      case DstAlphaFactor:
        blendFactor = GPUBlendFactor.DstAlpha;
        break;
      case OneMinusDstAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusDstAlpha;
        break;
      case SrcAlphaSaturateFactor:
        blendFactor = GPUBlendFactor.SrcAlphaSaturated;
        break;
      case BlendColorFactor:
        blendFactor = GPUBlendFactor.Constant;
        break;
      case OneMinusBlendColorFactor:
        blendFactor = GPUBlendFactor.OneMinusConstant;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", blend);
    }
    return blendFactor;
  }
  _getStencilCompare(material) {
    let stencilCompare;
    const stencilFunc = material.stencilFunc;
    switch (stencilFunc) {
      case NeverStencilFunc:
        stencilCompare = GPUCompareFunction.Never;
        break;
      case AlwaysStencilFunc:
        stencilCompare = GPUCompareFunction.Always;
        break;
      case LessStencilFunc:
        stencilCompare = GPUCompareFunction.Less;
        break;
      case LessEqualStencilFunc:
        stencilCompare = GPUCompareFunction.LessEqual;
        break;
      case EqualStencilFunc:
        stencilCompare = GPUCompareFunction.Equal;
        break;
      case GreaterEqualStencilFunc:
        stencilCompare = GPUCompareFunction.GreaterEqual;
        break;
      case GreaterStencilFunc:
        stencilCompare = GPUCompareFunction.Greater;
        break;
      case NotEqualStencilFunc:
        stencilCompare = GPUCompareFunction.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", stencilFunc);
    }
    return stencilCompare;
  }
  _getStencilOperation(op) {
    let stencilOperation;
    switch (op) {
      case KeepStencilOp:
        stencilOperation = GPUStencilOperation.Keep;
        break;
      case ZeroStencilOp:
        stencilOperation = GPUStencilOperation.Zero;
        break;
      case ReplaceStencilOp:
        stencilOperation = GPUStencilOperation.Replace;
        break;
      case InvertStencilOp:
        stencilOperation = GPUStencilOperation.Invert;
        break;
      case IncrementStencilOp:
        stencilOperation = GPUStencilOperation.IncrementClamp;
        break;
      case DecrementStencilOp:
        stencilOperation = GPUStencilOperation.DecrementClamp;
        break;
      case IncrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.IncrementWrap;
        break;
      case DecrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", stencilOperation);
    }
    return stencilOperation;
  }
  _getBlendOperation(blendEquation) {
    let blendOperation;
    switch (blendEquation) {
      case AddEquation:
        blendOperation = GPUBlendOperation.Add;
        break;
      case SubtractEquation:
        blendOperation = GPUBlendOperation.Subtract;
        break;
      case ReverseSubtractEquation:
        blendOperation = GPUBlendOperation.ReverseSubtract;
        break;
      case MinEquation:
        blendOperation = GPUBlendOperation.Min;
        break;
      case MaxEquation:
        blendOperation = GPUBlendOperation.Max;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.", blendEquation);
    }
    return blendOperation;
  }
  _getPrimitiveState(object, geometry, material) {
    const descriptor = {};
    const utils = this.backend.utils;
    descriptor.topology = utils.getPrimitiveTopology(object, material);
    if (geometry.index !== null && object.isLine === true && object.isLineSegments !== true) {
      descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
    }
    switch (material.side) {
      case FrontSide:
        descriptor.frontFace = GPUFrontFace.CCW;
        descriptor.cullMode = GPUCullMode.Back;
        break;
      case BackSide:
        descriptor.frontFace = GPUFrontFace.CCW;
        descriptor.cullMode = GPUCullMode.Front;
        break;
      case DoubleSide:
        descriptor.frontFace = GPUFrontFace.CCW;
        descriptor.cullMode = GPUCullMode.None;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.", material.side);
        break;
    }
    return descriptor;
  }
  _getColorWriteMask(material) {
    return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;
  }
  _getDepthCompare(material) {
    let depthCompare;
    if (material.depthTest === false) {
      depthCompare = GPUCompareFunction.Always;
    } else {
      const depthFunc = material.depthFunc;
      switch (depthFunc) {
        case NeverDepth:
          depthCompare = GPUCompareFunction.Never;
          break;
        case AlwaysDepth:
          depthCompare = GPUCompareFunction.Always;
          break;
        case LessDepth:
          depthCompare = GPUCompareFunction.Less;
          break;
        case LessEqualDepth:
          depthCompare = GPUCompareFunction.LessEqual;
          break;
        case EqualDepth:
          depthCompare = GPUCompareFunction.Equal;
          break;
        case GreaterEqualDepth:
          depthCompare = GPUCompareFunction.GreaterEqual;
          break;
        case GreaterDepth:
          depthCompare = GPUCompareFunction.Greater;
          break;
        case NotEqualDepth:
          depthCompare = GPUCompareFunction.NotEqual;
          break;
        default:
          console.error("THREE.WebGPUPipelineUtils: Invalid depth function.", depthFunc);
      }
    }
    return depthCompare;
  }
};
var WebGPUPipelineUtils_default = WebGPUPipelineUtils;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPUBackend.js
var _staticAdapter = null;
if (navigator.gpu !== void 0) {
  _staticAdapter = await navigator.gpu.requestAdapter();
}
var WebGPUBackend = class extends Backend_default {
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGPUBackend = true;
    this.parameters.antialias = parameters.antialias === true;
    if (this.parameters.antialias === true) {
      this.parameters.sampleCount = parameters.sampleCount === void 0 ? 4 : parameters.sampleCount;
    } else {
      this.parameters.sampleCount = 1;
    }
    this.parameters.requiredLimits = parameters.requiredLimits === void 0 ? {} : parameters.requiredLimits;
    this.adapter = null;
    this.device = null;
    this.context = null;
    this.colorBuffer = null;
    this.utils = new WebGPUUtils_default(this);
    this.attributeUtils = new WebGPUAttributeUtils_default(this);
    this.bindingUtils = new WebGPUBindingUtils_default(this);
    this.pipelineUtils = new WebGPUPipelineUtils_default(this);
    this.textureUtils = new WebGPUTextureUtils_default(this);
    this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  async init(renderer) {
    await super.init(renderer);
    const parameters = this.parameters;
    const adapterOptions = {
      powerPreference: parameters.powerPreference
    };
    const adapter = await navigator.gpu.requestAdapter(adapterOptions);
    if (adapter === null) {
      throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
    }
    const features = Object.values(GPUFeatureName);
    const supportedFeatures = [];
    for (const name of features) {
      if (adapter.features.has(name)) {
        supportedFeatures.push(name);
      }
    }
    const deviceDescriptor = {
      requiredFeatures: supportedFeatures,
      requiredLimits: parameters.requiredLimits
    };
    const device = await adapter.requestDevice(deviceDescriptor);
    const context2 = parameters.context !== void 0 ? parameters.context : renderer.domElement.getContext("webgpu");
    this.adapter = adapter;
    this.device = device;
    this.context = context2;
    this.context.configure({
      device: this.device,
      format: GPUTextureFormat.BGRA8Unorm,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      alphaMode: "premultiplied"
    });
    this.updateSize();
  }
  get coordinateSystem() {
    return WebGPUCoordinateSystem;
  }
  async getArrayBufferAsync(attribute) {
    return await this.attributeUtils.getArrayBufferAsync(attribute);
  }
  beginRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const device = this.device;
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    let occlusionQuerySet;
    if (occlusionQueryCount > 0) {
      if (renderContextData.currentOcclusionQuerySet)
        renderContextData.currentOcclusionQuerySet.destroy();
      if (renderContextData.currentOcclusionQueryBuffer)
        renderContextData.currentOcclusionQueryBuffer.destroy();
      renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
      renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
      occlusionQuerySet = device.createQuerySet({ type: "occlusion", count: occlusionQueryCount });
      renderContextData.occlusionQuerySet = occlusionQuerySet;
      renderContextData.occlusionQueryIndex = 0;
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.lastOcclusionObject = null;
    }
    const descriptor = {
      colorAttachments: [{
        view: null
      }],
      depthStencilAttachment: {
        view: null
      },
      occlusionQuerySet
    };
    const colorAttachment = descriptor.colorAttachments[0];
    const depthStencilAttachment = descriptor.depthStencilAttachment;
    const antialias = this.parameters.antialias;
    if (renderContext.textures !== null) {
      const textures = renderContext.textures;
      descriptor.colorAttachments = [];
      const colorAttachments = descriptor.colorAttachments;
      for (let i = 0; i < textures.length; i++) {
        const textureData = this.get(textures[i]);
        const textureView = textureData.texture.createView({
          baseMipLevel: renderContext.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: renderContext.activeCubeFace,
          dimension: GPUTextureViewDimension.TwoD
        });
        let view, resolveTarget;
        if (textureData.msaaTexture !== void 0) {
          view = textureData.msaaTexture.createView();
          resolveTarget = textureView;
        } else {
          view = textureView;
          resolveTarget = void 0;
        }
        colorAttachments.push({
          view,
          resolveTarget,
          loadOp: GPULoadOp.Load,
          storeOp: GPUStoreOp.Store
        });
      }
      const depthTextureData = this.get(renderContext.depthTexture);
      depthStencilAttachment.view = depthTextureData.texture.createView();
      if (renderContext.stencil && renderContext.depthTexture.format === DepthFormat) {
        renderContext.stencil = false;
      }
    } else {
      if (antialias === true) {
        colorAttachment.view = this.colorBuffer.createView();
        colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();
      } else {
        colorAttachment.view = this.context.getCurrentTexture().createView();
        colorAttachment.resolveTarget = void 0;
      }
      depthStencilAttachment.view = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil).createView();
    }
    if (renderContext.textures !== null) {
      const colorAttachments = descriptor.colorAttachments;
      for (let i = 0; i < colorAttachments.length; i++) {
        const colorAttachment2 = colorAttachments[i];
        if (renderContext.clearColor) {
          colorAttachment2.clearValue = renderContext.clearColorValue;
          colorAttachment2.loadOp = GPULoadOp.Clear;
          colorAttachment2.storeOp = GPUStoreOp.Store;
        } else {
          colorAttachment2.loadOp = GPULoadOp.Load;
          colorAttachment2.storeOp = GPUStoreOp.Store;
        }
      }
    } else {
      if (renderContext.clearColor) {
        colorAttachment.clearValue = renderContext.clearColorValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
        colorAttachment.storeOp = GPUStoreOp.Store;
      } else {
        colorAttachment.loadOp = GPULoadOp.Load;
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
    }
    if (renderContext.depth) {
      if (renderContext.clearDepth) {
        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      }
    }
    if (renderContext.stencil) {
      if (renderContext.clearStencil) {
        depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      }
    }
    const encoder = device.createCommandEncoder({ label: "renderContext_" + renderContext.id });
    const currentPass = encoder.beginRenderPass(descriptor);
    renderContextData.descriptor = descriptor;
    renderContextData.encoder = encoder;
    renderContextData.currentPass = currentPass;
    renderContextData.currentSets = { attributes: {} };
    if (renderContext.viewport) {
      this.updateViewport(renderContext);
    }
    if (renderContext.scissor) {
      const { x, y, width, height } = renderContext.scissorValue;
      currentPass.setScissorRect(x, renderContext.height - height - y, width, height);
    }
  }
  finishRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
      renderContextData.currentPass.endOcclusionQuery();
    }
    renderContextData.currentPass.end();
    if (occlusionQueryCount > 0) {
      const bufferSize = occlusionQueryCount * 8;
      let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);
      if (queryResolveBuffer === void 0) {
        queryResolveBuffer = this.device.createBuffer(
          {
            size: bufferSize,
            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
          }
        );
        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);
      }
      const readBuffer = this.device.createBuffer(
        {
          size: bufferSize,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);
      renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);
      renderContextData.occlusionQueryBuffer = readBuffer;
      this.resolveOccludedAsync(renderContext);
    }
    this.device.queue.submit([renderContextData.encoder.finish()]);
    if (renderContext.textures !== null) {
      const textures = renderContext.textures;
      for (let i = 0; i < textures.length; i++) {
        const texture2 = textures[i];
        if (texture2.generateMipmaps === true) {
          this.textureUtils.generateMipmaps(texture2);
        }
      }
    }
  }
  isOccluded(renderContext, object) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object);
  }
  async resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;
    if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueryBuffer = null;
      await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);
      const buffer = currentOcclusionQueryBuffer.getMappedRange();
      const results = new BigUint64Array(buffer);
      for (let i = 0; i < currentOcclusionQueryObjects.length; i++) {
        if (results[i] !== 0n) {
          occluded.add(currentOcclusionQueryObjects[i]);
        }
      }
      currentOcclusionQueryBuffer.destroy();
      renderContextData.occluded = occluded;
    }
  }
  updateViewport(renderContext) {
    const { currentPass } = this.get(renderContext);
    let { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;
    currentPass.setViewport(x, renderContext.height - height - y, width, height, minDepth, maxDepth);
  }
  clear(color, depth, stencil, renderTargetData = null) {
    const device = this.device;
    const renderer = this.renderer;
    const colorAttachments = [];
    let depthStencilAttachment;
    let clearValue;
    let supportsDepth;
    let supportsStencil;
    if (color) {
      const clearColor = this.getClearColor();
      clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };
    }
    if (renderTargetData === null) {
      supportsDepth = renderer.depth;
      supportsStencil = renderer.stencil;
      depth = depth && supportsDepth;
      stencil = stencil && supportsStencil;
      if (color) {
        const antialias = this.parameters.antialias;
        const colorAttachment = {};
        if (antialias === true) {
          colorAttachment.view = this.colorBuffer.createView();
          colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();
        } else {
          colorAttachment.view = this.context.getCurrentTexture().createView();
        }
        colorAttachment.clearValue = clearValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
        colorAttachment.storeOp = GPUStoreOp.Store;
        colorAttachments.push(colorAttachment);
      }
      if (depth || stencil) {
        depthStencilAttachment = {
          view: this.textureUtils.getDepthBuffer(renderer.depth, renderer.stencil).createView()
        };
      }
    } else {
      supportsDepth = renderTargetData.depth;
      supportsStencil = renderTargetData.stencil;
      depth = depth && supportsDepth;
      stencil = stencil && supportsStencil;
      if (color) {
        for (const texture2 of renderTargetData.textures) {
          const textureData = this.get(texture2);
          const textureView = textureData.texture.createView();
          let view, resolveTarget;
          if (textureData.msaaTexture !== void 0) {
            view = textureData.msaaTexture.createView();
            resolveTarget = textureView;
          } else {
            view = textureView;
            resolveTarget = void 0;
          }
          colorAttachments.push({
            view,
            resolveTarget,
            clearValue,
            loadOp: GPULoadOp.Clear,
            storeOp: GPUStoreOp.Store
          });
        }
      }
      if (depth || stencil) {
        const depthTextureData = this.get(renderTargetData.depthTexture);
        depthStencilAttachment = {
          view: depthTextureData.texture.createView()
        };
      }
    }
    if (depthStencilAttachment !== void 0) {
      if (depth) {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.depthClearValue = renderer.getClearDepth();
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      }
      if (stencil) {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      }
    }
    const encoder = device.createCommandEncoder({});
    const currentPass = encoder.beginRenderPass({
      colorAttachments,
      depthStencilAttachment
    });
    currentPass.end();
    device.queue.submit([encoder.finish()]);
  }
  // compute
  beginCompute(computeGroup) {
    const groupGPU = this.get(computeGroup);
    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder({});
    groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass();
  }
  compute(computeGroup, computeNode, bindings, pipeline) {
    const { passEncoderGPU } = this.get(computeGroup);
    const pipelineGPU = this.get(pipeline).pipeline;
    passEncoderGPU.setPipeline(pipelineGPU);
    const bindGroupGPU = this.get(bindings).group;
    passEncoderGPU.setBindGroup(0, bindGroupGPU);
    passEncoderGPU.dispatchWorkgroups(computeNode.dispatchCount);
  }
  finishCompute(computeGroup) {
    const groupData = this.get(computeGroup);
    groupData.passEncoderGPU.end();
    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);
  }
  // render object
  draw(renderObject, info) {
    const { object, geometry, context: context2, pipeline } = renderObject;
    const bindingsData = this.get(renderObject.getBindings());
    const contextData = this.get(context2);
    const pipelineGPU = this.get(pipeline).pipeline;
    const currentSets = contextData.currentSets;
    const passEncoderGPU = contextData.currentPass;
    if (currentSets.pipeline !== pipelineGPU) {
      passEncoderGPU.setPipeline(pipelineGPU);
      currentSets.pipeline = pipelineGPU;
    }
    const bindGroupGPU = bindingsData.group;
    passEncoderGPU.setBindGroup(0, bindGroupGPU);
    const index = renderObject.getIndex();
    const hasIndex = index !== null;
    if (hasIndex === true) {
      if (currentSets.index !== index) {
        const buffer = this.get(index).buffer;
        const indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
        passEncoderGPU.setIndexBuffer(buffer, indexFormat);
        currentSets.index = index;
      }
    }
    const vertexBuffers = renderObject.getVertexBuffers();
    for (let i = 0, l = vertexBuffers.length; i < l; i++) {
      const vertexBuffer = vertexBuffers[i];
      if (currentSets.attributes[i] !== vertexBuffer) {
        const buffer = this.get(vertexBuffer).buffer;
        passEncoderGPU.setVertexBuffer(i, buffer);
        currentSets.attributes[i] = vertexBuffer;
      }
    }
    if (contextData.occlusionQuerySet !== void 0) {
      const lastObject = contextData.lastOcclusionObject;
      if (lastObject !== object) {
        if (lastObject !== null && lastObject.occlusionTest === true) {
          passEncoderGPU.endOcclusionQuery();
          contextData.occlusionQueryIndex++;
        }
        if (object.occlusionTest === true) {
          passEncoderGPU.beginOcclusionQuery(contextData.occlusionQueryIndex);
          contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;
        }
        contextData.lastOcclusionObject = object;
      }
    }
    const drawRange = geometry.drawRange;
    const firstVertex = drawRange.start;
    const instanceCount = this.getInstanceCount(renderObject);
    if (instanceCount === 0)
      return;
    if (hasIndex === true) {
      const indexCount = drawRange.count !== Infinity ? drawRange.count : index.count;
      passEncoderGPU.drawIndexed(indexCount, instanceCount, firstVertex, 0, 0);
      info.update(object, indexCount, instanceCount);
    } else {
      const positionAttribute = geometry.attributes.position;
      const vertexCount = drawRange.count !== Infinity ? drawRange.count : positionAttribute.count;
      passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);
      info.update(object, vertexCount, instanceCount);
    }
  }
  // cache key
  needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    const { object, material } = renderObject;
    const utils = this.utils;
    const sampleCount = utils.getSampleCount(renderObject.context);
    const colorSpace = utils.getCurrentColorSpace(renderObject.context);
    const colorFormat = utils.getCurrentColorFormat(renderObject.context);
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
    const primitiveTopology = utils.getPrimitiveTopology(object, material);
    let needsUpdate = false;
    if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat || data.primitiveTopology !== primitiveTopology) {
      data.material = material;
      data.materialVersion = material.version;
      data.transparent = material.transparent;
      data.blending = material.blending;
      data.premultipliedAlpha = material.premultipliedAlpha;
      data.blendSrc = material.blendSrc;
      data.blendDst = material.blendDst;
      data.blendEquation = material.blendEquation;
      data.blendSrcAlpha = material.blendSrcAlpha;
      data.blendDstAlpha = material.blendDstAlpha;
      data.blendEquationAlpha = material.blendEquationAlpha;
      data.colorWrite = material.colorWrite;
      data.depthWrite = material.depthWrite;
      data.depthTest = material.depthTest;
      data.depthFunc = material.depthFunc;
      data.stencilWrite = material.stencilWrite;
      data.stencilFunc = material.stencilFunc;
      data.stencilFail = material.stencilFail;
      data.stencilZFail = material.stencilZFail;
      data.stencilZPass = material.stencilZPass;
      data.stencilFuncMask = material.stencilFuncMask;
      data.stencilWriteMask = material.stencilWriteMask;
      data.side = material.side;
      data.alphaToCoverage = material.alphaToCoverage;
      data.sampleCount = sampleCount;
      data.colorSpace = colorSpace;
      data.colorFormat = colorFormat;
      data.depthStencilFormat = depthStencilFormat;
      data.primitiveTopology = primitiveTopology;
      needsUpdate = true;
    }
    return needsUpdate;
  }
  getRenderCacheKey(renderObject) {
    const { object, material } = renderObject;
    const utils = this.utils;
    const renderContext = renderObject.context;
    return [
      material.transparent,
      material.blending,
      material.premultipliedAlpha,
      material.blendSrc,
      material.blendDst,
      material.blendEquation,
      material.blendSrcAlpha,
      material.blendDstAlpha,
      material.blendEquationAlpha,
      material.colorWrite,
      material.depthWrite,
      material.depthTest,
      material.depthFunc,
      material.stencilWrite,
      material.stencilFunc,
      material.stencilFail,
      material.stencilZFail,
      material.stencilZPass,
      material.stencilFuncMask,
      material.stencilWriteMask,
      material.side,
      utils.getSampleCount(renderContext),
      utils.getCurrentColorSpace(renderContext),
      utils.getCurrentColorFormat(renderContext),
      utils.getCurrentDepthStencilFormat(renderContext),
      utils.getPrimitiveTopology(object, material)
    ].join();
  }
  // textures
  createSampler(texture2) {
    this.textureUtils.createSampler(texture2);
  }
  destroySampler(texture2) {
    this.textureUtils.destroySampler(texture2);
  }
  createDefaultTexture(texture2) {
    this.textureUtils.createDefaultTexture(texture2);
  }
  createTexture(texture2, options) {
    this.textureUtils.createTexture(texture2, options);
  }
  updateTexture(texture2, options) {
    this.textureUtils.updateTexture(texture2, options);
  }
  generateMipmaps(texture2) {
    this.textureUtils.generateMipmaps(texture2);
  }
  destroyTexture(texture2) {
    this.textureUtils.destroyTexture(texture2);
  }
  copyTextureToBuffer(texture2, x, y, width, height) {
    return this.textureUtils.copyTextureToBuffer(texture2, x, y, width, height);
  }
  // node builder
  createNodeBuilder(object, renderer, scene = null) {
    return new WGSLNodeBuilder_default(object, renderer, scene);
  }
  // program
  createProgram(program) {
    const programGPU = this.get(program);
    programGPU.module = {
      module: this.device.createShaderModule({ code: program.code, label: program.stage }),
      entryPoint: "main"
    };
  }
  destroyProgram(program) {
    this.delete(program);
  }
  // pipelines
  createRenderPipeline(renderObject) {
    this.pipelineUtils.createRenderPipeline(renderObject);
  }
  createComputePipeline(computePipeline, bindings) {
    this.pipelineUtils.createComputePipeline(computePipeline, bindings);
  }
  // bindings
  createBindings(bindings) {
    this.bindingUtils.createBindings(bindings);
  }
  updateBindings(bindings) {
    this.bindingUtils.createBindings(bindings);
  }
  updateBinding(binding) {
    this.bindingUtils.updateBinding(binding);
  }
  // attributes
  createIndexAttribute(attribute) {
    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createAttribute(attribute) {
    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  createStorageAttribute(attribute) {
    this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  updateAttribute(attribute) {
    this.attributeUtils.updateAttribute(attribute);
  }
  destroyAttribute(attribute) {
    this.attributeUtils.destroyAttribute(attribute);
  }
  // canvas
  updateSize() {
    this.colorBuffer = this.textureUtils.getColorBuffer();
  }
  // utils public
  getMaxAnisotropy() {
    return 16;
  }
  hasFeature(name) {
    const adapter = this.adapter || _staticAdapter;
    const features = Object.values(GPUFeatureName);
    if (features.includes(name) === false) {
      throw new Error("THREE.WebGPURenderer: Unknown WebGPU GPU feature: " + name);
    }
    return adapter.features.has(name);
  }
  copyFramebufferToTexture(texture2, renderContext) {
    const renderContextData = this.get(renderContext);
    const { encoder, descriptor } = renderContextData;
    let sourceGPU = null;
    if (texture2.isFramebufferTexture) {
      sourceGPU = this.context.getCurrentTexture();
    } else if (texture2.isDepthTexture) {
      sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);
    }
    const destinationGPU = this.get(texture2).texture;
    renderContextData.currentPass.end();
    encoder.copyTextureToTexture(
      {
        texture: sourceGPU,
        origin: { x: 0, y: 0, z: 0 }
      },
      {
        texture: destinationGPU
      },
      [
        texture2.image.width,
        texture2.image.height
      ]
    );
    if (texture2.generateMipmaps)
      this.textureUtils.generateMipmaps(texture2);
    descriptor.colorAttachments[0].loadOp = GPULoadOp.Load;
    if (renderContext.depth)
      descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
    if (renderContext.stencil)
      descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
    renderContextData.currentPass = encoder.beginRenderPass(descriptor);
    renderContextData.currentSets = { attributes: {} };
  }
};
var WebGPUBackend_default = WebGPUBackend;

// node_modules/three/examples/jsm/renderers/webgpu/WebGPURenderer.js
var WebGPURenderer = class extends Renderer_default {
  constructor(parameters = {}) {
    let BackendClass;
    if (WebGPU_default.isAvailable()) {
      BackendClass = WebGPUBackend_default;
    } else {
      BackendClass = WebGLBackend_default;
      console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.");
    }
    const backend = new BackendClass(parameters);
    super(backend, parameters);
    this.isWebGPURenderer = true;
  }
};
var WebGPURenderer_default = WebGPURenderer;
export {
  WebGPURenderer_default as default
};
//# sourceMappingURL=three_addons_renderers_webgpu_WebGPURenderer__js.js.map
